<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1. 入门知识 环境变量Path：相当于在电脑中存储一些路径，因此在cmd命令界面中，不需要进入到相对应的路径中即可。  bin-存放各种工具命令，如javac和java；conf：存放相关配置文件；include：存放特定的头文件；jmods：存放各种模块；legl:存放各种授权文件；lib-存放工具的一些补充JAR包  程序运行分为两步：编译（javac xxx.java）；执行（java x">
<meta property="og:type" content="article">
<meta property="og:title" content="java tutorial">
<meta property="og:url" content="http://example.com/2023/10/28/java-tutorial/index.html">
<meta property="og:site_name" content="windbro的小黑屋">
<meta property="og:description" content="1. 入门知识 环境变量Path：相当于在电脑中存储一些路径，因此在cmd命令界面中，不需要进入到相对应的路径中即可。  bin-存放各种工具命令，如javac和java；conf：存放相关配置文件；include：存放特定的头文件；jmods：存放各种模块；legl:存放各种授权文件；lib-存放工具的一些补充JAR包  程序运行分为两步：编译（javac xxx.java）；执行（java x">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="d:\learning_programs\hexo_programs\mywebsite\source\_posts\images\java-tutorial\image-20230915170631761.png">
<meta property="og:image" content="d:\learning_programs\hexo_programs\mywebsite\source\_posts\images\java-tutorial\image-20231008213613772.png">
<meta property="og:image" content="d:\learning_programs\hexo_programs\mywebsite\source\_posts\images\java-tutorial\image-20231009103309534.png">
<meta property="og:image" content="d:\learning_programs\hexo_programs\mywebsite\source\_posts\images\java-tutorial\image-20231009105355122.png">
<meta property="og:image" content="d:\learning_programs\hexo_programs\mywebsite\source\_posts\images\java-tutorial\image-20231009111558286.png">
<meta property="article:published_time" content="2023-10-28T11:48:58.000Z">
<meta property="article:modified_time" content="2023-10-28T12:21:48.375Z">
<meta property="article:author" content="windbro">
<meta property="article:tag" content="java tutorial">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:\learning_programs\hexo_programs\mywebsite\source\_posts\images\java-tutorial\image-20230915170631761.png">


<link rel="canonical" href="http://example.com/2023/10/28/java-tutorial/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/10/28/java-tutorial/","path":"2023/10/28/java-tutorial/","title":"java tutorial"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>java tutorial | windbro的小黑屋</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">windbro的小黑屋</p>
      <i class="logo-line"></i>
    </a>
      <img class="custom-logo-image" src="/images/logo.jpg" alt="windbro的小黑屋">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">1. 入门知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B0%8F%E6%A6%82%E5%BF%B5"><span class="nav-number">2.</span> <span class="nav-text">2. 小概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.</span> <span class="nav-text">3. 运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">4.</span> <span class="nav-text">4. 流程控制语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%95%B0%E7%BB%84"><span class="nav-number">5.</span> <span class="nav-text">5. 数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%96%B9%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">6. 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.</span> <span class="nav-text">7. 面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-API-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">8.</span> <span class="nav-text">8. API &amp; 字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E9%9B%86%E5%90%88"><span class="nav-number">9.</span> <span class="nav-text">9. 集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-static"><span class="nav-number">10.</span> <span class="nav-text">10. static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E7%BB%A7%E6%89%BF"><span class="nav-number">11.</span> <span class="nav-text">11. 继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E5%A4%9A%E6%80%81"><span class="nav-number">12.</span> <span class="nav-text">12. 多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E5%8C%85%E4%B8%8Efinal"><span class="nav-number">13.</span> <span class="nav-text">13. 包与final</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%92%8C%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">14.</span> <span class="nav-text">14. 权限修饰符和代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">15.</span> <span class="nav-text">15. 抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E6%8E%A5%E5%8F%A3"><span class="nav-number">16.</span> <span class="nav-text">16. 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">17.</span> <span class="nav-text">17. 内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-%E6%B8%B8%E6%88%8F%E6%89%93%E5%8C%85exe"><span class="nav-number">18.</span> <span class="nav-text">18. 游戏打包exe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="nav-number">19.</span> <span class="nav-text">*IDEA快捷键</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">windbro</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/28/java-tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windbro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windbro的小黑屋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="java tutorial | windbro的小黑屋">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java tutorial
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-10-28 19:48:58 / 修改时间：20:21:48" itemprop="dateCreated datePublished" datetime="2023-10-28T19:48:58+08:00">2023-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/code-tutorial/" itemprop="url" rel="index"><span itemprop="name">code-tutorial</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h3 id="1-入门知识"><a href="#1-入门知识" class="headerlink" title="1. 入门知识"></a>1. 入门知识</h3><ol>
<li><p>环境变量Path：相当于在电脑中存储一些路径，因此在cmd命令界面中，不需要进入到相对应的路径中即可。</p>
</li>
<li><p>bin-存放各种工具命令，如javac和java；conf：存放相关配置文件；include：存放特定的头文件；jmods：存放各种模块；legl:存放各种授权文件；lib-存放工具的一些补充JAR包</p>
</li>
<li><p>程序运行分为两步：<strong>编译</strong>（javac xxx.java）；<strong>执行</strong>（java xxx），执行的时候不需要后缀</p>
</li>
<li><p>Java SE：java语言的标准版，用于桌面应用的开发，是其他两个版本的<strong>基础</strong>。（但是并不合适，常见的是C和C++）</p>
<p>Java ME：java语言的小型版，用于嵌入式电子设备和小型移动设备（已凉）</p>
<p>Java EE：java语言的企业版，用于Web方向的网站开发。网站开发分为浏览器+服务器，java主要用于后者（主力）</p>
</li>
<li><p>java优点：面向对象；安全性（代码漏洞少）；多线程；简单易用；开源；跨平台（指操作系统，Windows, Mac, Linux）</p>
</li>
<li><p>编译型语言(c, c++)：整体翻译；解释型语言（python）：逐行翻译。</p>
<p>混合型语言(java)：首先整体编译为.class二进制字节码文件，再按行交给设备运行（运行在<strong>虚拟机</strong>中）。java不直接运行在操作系统中，而是在虚拟机中，这就是java能够多平台运行的原因</p>
</li>
<li><p>JVM: java virtual machine, java虚拟机；  核心类库：java预先定义的内容</p>
<p>javac：编译工具；java：运行工具；jdb 调试工具；jhat 内存分析工具</p>
</li>
</ol>
<p>​		JDK：java开发工具，包含JVM, 核心类库，核心类库，开发工具；</p>
<p>​		JRE: java运行环境，包含JVM， 核心类库，运行工具</p>
<h3 id="2-小概念"><a href="#2-小概念" class="headerlink" title="2. 小概念"></a>2. 小概念</h3><ol>
<li><p>注释 - 单行注释&#x2F;&#x2F;， 多行注释&#x2F;* <em>&#x2F;，文档注释 &#x2F;</em>* *&#x2F;，主要用于说明文档 ; </p>
</li>
<li><p>关键字：被java赋予<strong>特定含义</strong>的英文单词。特点：关键字的字母全部<strong>小写</strong>；常用的代码编译器，会将关键字用<strong>特殊颜色</strong>标出。举例：</p>
<p>class: 用于创建或定义一个类，是java最基本的组成单元</p>
</li>
<li><p>字面量：主要用于告诉程序员，数据在程序中的书写格式。如：整数和小数类型；字符串类型和字符类型（前者需要“”， 后者需要’’）；布尔类型(true, false)和空类型（null）</p>
<p>常见特殊字符：\t, 制表符，在打印的时候吧前面字符串的长度补齐到8或8的倍数，最少补1个空格，最多补8个空格</p>
</li>
<li><p>变量：在程序中可能会改变的量。定义格式：数据类型 变量名 &#x3D; 数据值；</p>
<p>变量注意事项：i. 只能存一个值；ii. 变量名不允许重复； iii. 一条语句可以定义多个变量； iv: 变量<strong>使用前一定要赋值</strong>； v: 变量要注意<strong>作用范围</strong></p>
</li>
<li><p><strong>类名一定要与文件名统一！！！</strong></p>
</li>
<li><p>计算机的存储规律：主要分为文本、图片、声音三类，但是都是以二进制的形式来存储。</p>
<p>计算机中各种进制的表型形式：二进制 - 0b；十进制 - 无前缀；八进制  - 0； 十六进制 - 0x；</p>
</li>
<li><p>数据类型：基本数据类型+引用数据类型。基本数据类型：整数（byte, short, int, long）；浮点数（float, double）；字符（char）;布尔类型（boolean）</p>
</li>
<li><p>标识符：给类、方法、变量起的名字。</p>
<p>硬性要求：</p>
<p>i. 有数字、字母、下划线_、美元$构成</p>
<p>ii. 不能以数字开头</p>
<p>iii. 不能是关键字</p>
<p>iv. 区分大小写</p>
<p>软性建议：</p>
<p>i. 小驼峰命名法：一个单词时全部小写（name），多个单词时第一个单词首字母小写，后续的单词首字母大写(nameFirst) 。<strong>主要用于方法、变量</strong></p>
<p>ii. 大驼峰命名法：一个或多个单词组成时，全部单词首字母大写。<strong>主要用于类名</strong></p>
<p>iii. <strong>见名知意</strong></p>
</li>
<li><p>键盘录入<strong>Scanner</strong>类，可以接受键盘输入的<strong>数字</strong>。</p>
<p>使用步骤：</p>
<p>i. 导包(import java.util.Scanner)；</p>
<p>ii. 创建对象(Scanner sc &#x3D; new Scanner(System.in))；</p>
<p>iii. 接受数据(int i &#x3D; sc.nextInt())</p>
<p><strong>Scanner的两套体系：</strong></p>
<p>第一套体系（空格，制表符或回车 停止接收）：</p>
<p>i. nextInt() : 接收整数</p>
<p>ii. nextDouble() : 接收小数</p>
<p>iii. next() : 接收字符串</p>
<p>第二套体系（仅停车 停止接收，其余皆可）：</p>
<p>i. nextLine() : 接收字符串</p>
</li>
<li><p>IDEA项目结构：project(项目)；module（模块）；package（包）；class（类）</p>
<p>对于包package，使用时常常创建多级包，用来表示所属关系。如com.itheima.demo1</p>
</li>
</ol>
<h3 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h3><ol>
<li>隐式转换（自动类型提升）：将取值范围小的数值，转换为取值范围大的数值。char, short, byte类型都会先转换为int类型，之后再参与计算</li>
<li>强制装换：将一个取值范围大的数值，赋值给取值给取值范围小的数值。（强制转换的优先级比较低，最好在后面添加小括号）</li>
<li>字符串相加：+操作中出现字符串时，此时相当于字符串的拼接，产生一个新的字符串。如：“123”+123 &#x3D; “123123”。连续+号，从左到右逐个进行</li>
<li>字符相加：先提升为int，再进行计算</li>
<li>java中包含自增运算符++和自减运算符–</li>
<li>逻辑运算符：&amp; | ^ ! ; 短路运算符：&amp;&amp; || 用于提高程序运行效率，只要能够判断结果，就不再继续向后运算。</li>
<li>三元运算符：A?B:C ;</li>
</ol>
<h3 id="4-流程控制语句"><a href="#4-流程控制语句" class="headerlink" title="4. 流程控制语句"></a>4. 流程控制语句</h3><ol>
<li><p>三种控制语句：顺序结构；分支结构；循环结构</p>
</li>
<li><p>if语句：</p>
<p>第一种格式：if(关系表达式){语句体;}</p>
<p>第二种格式：if(关系表达式){语句体;} else {语句体;}</p>
<p>第三种格式：if(关系表达式){语句体;} else if(关系表达式){语句体} … else {语句体}</p>
<p>switch语句：switch(表达式){case 值1: 语句体; break; case 值2: 语句体; break; default: 语句体; break;}</p>
<p>如果每个case语句后面只有一个执行语句，也可以这样：</p>
<p>switch(表达式){case 值1 -&gt; 语句体; case 值2 -&gt; 语句体; … default -&gt; 语句体}</p>
<p>switch(表达式){case 值1,2,3 -&gt; 语句体; case 值4, 5 -&gt; 语句体}</p>
</li>
<li><p>switch其他知识</p>
<p>i. default的位置和省略：default可以省略，此时如果不匹配则无执行内容； default需要设置在最后</p>
<p>ii. case的穿透：case如果匹配且后面无break，就会向下继续执行（可以用于case语句重复时的简化代码，如周1-4是工作日，周5-7是休息日）</p>
</li>
<li><p>for循环：</p>
<p>for(int i&#x3D;1; i&lt;&#x3D; 10; i++) { … }</p>
<p>while循环：</p>
<p>while(i&lt;10) { … }</p>
<p>do … while循环：</p>
<p>do { … } while { … }</p>
</li>
<li><p>break, continue语句：不解释</p>
</li>
<li><p>生成随机数：import java.util.Random; Random r &#x3D; new Random(); int num &#x3D; r.nextInt(100) (小括号内写的，是随机数的范围，以0开始，给定数-1为阶数);;</p>
</li>
</ol>
<h3 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h3><ol>
<li><p>数组：用于存储同种数据类型的多个值</p>
</li>
<li><p>定义方式：</p>
<p>i. 数组类型[] 数组名， 如：int[] array;（更常用） </p>
<p>ii. 数据类型 数组名[]，如：int array[];</p>
</li>
<li><p>数组的初始化：</p>
<p>静态初始化：int[] array &#x3D; new int[] {1, 2, 3, 4, 5}。<strong>注意：没有float类型的数组，一般小数默认为double类型！</strong></p>
<p>​						简写格式：int[] array &#x3D; {1, 2, 3, 4, 5};</p>
<p>动态初始化：int[] array &#x3D; new int[50]; <strong>注意：动态初始化时，new后面的数组长度可以是变量</strong></p>
<p>​						对于动态初始化，整数默认为0，小数默认为0.0，字符默认为’&#x2F;u0000’，即空格，布尔默认为false，引用默认为null</p>
</li>
<li><p>数组打印：直接打印arr，得到的是数组的地址值。实际打印采用：arr[10]类型格式</p>
</li>
<li><p>数组遍历：arr.length为数组的长度，随后for循环即可遍历。</p>
<p>​					简写方法：for(int num : arr) { … } 这时的缺点在于，不知道此时遍历元素的索引。</p>
</li>
<li><p><strong>java内存分配：</strong>主要分为五部分：栈，堆，方法区，本地方法栈，寄存器。</p>
<p>栈：<strong>方法</strong>运行时使用的内存，如main方法运行，进入方法栈中执行</p>
<p>堆：存储<strong>对象或者数组</strong>，new来创建的东西在该块内存中开辟空间并产生地址 。<strong>比如a&#x3D;10这样的语句，没有使用new，因此不适用堆空间，而是在栈内存！！！</strong></p>
<p>方法区：存储可以运行的<strong>class文件</strong></p>
<p>本地方法栈：JVM在使用操作系统功能时使用，与开发过程无关</p>
<p>寄存器：与CPU相关</p>
</li>
</ol>
<h3 id="6-方法"><a href="#6-方法" class="headerlink" title="6. 方法"></a>6. 方法</h3><ol>
<li><p>方法(method)是程序中<strong>最小的执行单元</strong>，要么全部执行，要么不执行。对于<strong>重复的代码、具有独立功能的代码</strong>，可以抽取到方法中。优点：提高代码的复用性、可维护性。</p>
</li>
<li><p>方法定义：</p>
<p>public static void 方法名(参数类型 参数, ….) {方法体; return 返回值}</p>
</li>
<li><p>形参：<strong>方法定义</strong>中的参数；</p>
<p>实参：实际参数，<strong>方法调用</strong>中的参数</p>
</li>
<li><p>方法注意事项：</p>
<p>i. 方法与方法之间是平级关系，不能互相嵌套</p>
<p>ii. 方法的编写顺序与执行顺序无关</p>
</li>
<li><p>方法重载</p>
<p>在同一个类中，定义了多个<strong>同名的方法</strong>，这样方法有<strong>同种的功能</strong>，但是具有<strong>不同的参数类型</strong>或者<strong>参数个数</strong>。</p>
<p><strong>方法重载的参数值必须是相同的，否则就是两个不同的方法，不能同名</strong></p>
<p>参数不同分为三种：个数不同，类型不同，顺序不同</p>
</li>
<li><p>基本数据类型：整数、浮点数、布尔、字符（变量中存储的是<strong>真实数据</strong>）</p>
<p>引用数据类型：例如array（使用new创建的，都是引用数据类型，在<strong>堆</strong>中开辟空间。变量在栈中记录的是地址，在堆中记录的是数据）</p>
</li>
<li><p><strong>在java中，如果传递的是基本数据类型，形参的改变不影响实参的值。</strong></p>
<p><strong>如果传递的是引用数据类型（如数据），此时传递的是地址值，因此会改变实参的值。</strong></p>
</li>
</ol>
<h3 id="7-面向对象"><a href="#7-面向对象" class="headerlink" title="7. 面向对象"></a>7. 面向对象</h3><ol>
<li><p>面向对象编程：通过获取<strong>特定对象</strong>来完成任务</p>
</li>
<li><p>面向对象学习什么：</p>
<p>i. 获取已有对象并使用</p>
<p>ii. 自己设计对象并使用</p>
</li>
<li><p>类：对象共同特征的描述。（相当于设计图）</p>
<p>对象：真实存在的具体物体。</p>
<p>类的组成：成员变量；成员方法；构造器；代码块；内部类。</p>
<p>对象的定义：类名 对象名 &#x3D; new 类名();</p>
<p>对象的调用：<strong>对象.成员变量</strong>； 对象.成员方法</p>
</li>
<li><p>定义类的补充注意事项：</p>
<p>Javabean类：用于描述一类事物的类，不写main函数</p>
<p>测试类：可以创建javabean类的对象并进行赋值使用</p>
<p>i. 类名首字母大写，使用<strong>大驼峰命名法</strong></p>
<p>ii. 一个java文件中可以定义多个class类，<strong>但只能一个类是public修饰，且该类名必须称为代码文件名</strong>。在实际开发中，<strong>一个文件尽量定义一个class类</strong></p>
<p>iii. 成员变量的完整定义格式：<strong>修饰符 数据类型 变量名称 &#x3D; 初始化值</strong>；一般无需指定初始化值，存在默认值。</p>
</li>
<li><p><strong>开发中类的设计</strong>：一般来说，名词设计为类，动词设计为类对应的方法。</p>
</li>
<li><p><strong>面向对象的三大特征：封装，继承，多态</strong></p>
<p><strong>封装</strong>：如何正确设计对象的属性和方法。对象代表什么，就得封装对应的数据，并提供数据对应的行为。<strong>简单来说，以人关门为例，门自身具有一个状态（开关），对该状态改变的方法就属于人</strong></p>
</li>
<li><p><strong>private</strong>：是一个权限修饰符，可以修饰成员（成员变量和成员方法），<strong>只能在本类中访问</strong>。</p>
<p>作用：使代码更健壮、安全（如age需要代表的范围）。</p>
<p>常用方法：设置属性为private，但是设置public void setAge, public int getAge.</p>
<p><strong>对于每个私有化的成员变量，都要提供get和set方法</strong></p>
</li>
<li><p>就近原则：在类的方法内和方法外的变量同名时，使用该变量会就行</p>
</li>
<li><p><strong>构造方法</strong>：也叫构造器，构造函数。</p>
<p>作用：在创建变量时，给成员变量进行赋值。</p>
<p>格式：修饰符 类名（参数）{方法体；}</p>
<p>特点：</p>
<p>i. 方法名与类名相同，大小写一致</p>
<p>ii. 没有返回值类型，连void都没有</p>
<p>iii. 没有返回值，因此不能有return</p>
<p>执行时机：</p>
<p>创建对象时有虚拟机调用， 不能手动调用；每创建一个对象，就调用一次。</p>
<p><strong>一般来说，我们在创建类时，还是会写空参构造。因为在写了有参构造后，虚拟机就不再自动生成无参构造</strong></p>
</li>
<li><p>注意事项</p>
<p>i. 未定义构造方法时，系统会构造默认的午餐构造</p>
<p>ii.构造函数的重构。方法名相同，参数不同</p>
<p>iii. <strong>一般来说，我们至少要写两个构造方法：无参构造方法和带全部参数的构造方法</strong></p>
<p>iv. 调用构造方法知识创造对象的一部分，而不是全部。构造方法的作用：给成员变量进行初始化</p>
</li>
<li><p>标准JavaBean注意事项：</p>
<p>i. 类名见名知意</p>
<p>ii. <strong>成员变量使用private修饰</strong></p>
<p>iii. 至少有两个构造方法：午餐构造和带全部参数的构造</p>
<p>iv. 要构造setXxx和getXxx</p>
</li>
<li><p>原空间：字节码文件时，进入的内存</p>
<p>栈内存：方法运行时进入的内存，变量也是在这里</p>
<p>堆：new创建的对象</p>
<p>一个对象的内存图：（以 Student s &#x3D; new Student();为例）加载class文件；申明局部变量；在堆内存中开辟一个空间；默认初始化；显示初始化；构造方法初始化；将堆内存中的地址值赋 值给左边的局部变量。</p>
</li>
<li><p>this的内存原理：菊粉局部变量和成员变量。this的本质：所在方法调用者的地址</p>
</li>
<li><p>成员变量：类中方法外的变量</p>
<p>局部变量：方法中的变量</p>
<p>区别：</p>
<p>类中位置不同（前者在类中方法外，后者在方法内）；</p>
<p>初始化值不同（前者有默认初始化值，后者没有，需要赋值）</p>
<p>内存位置不同（前者在堆内存中，后者在栈内存中）</p>
<p>生命周期不同（前者随着对象的创建而存在，随着对象的消失而消失；后者随着方法的调用而存在，随着方法的运行结束而消失）</p>
<p>作用域不同（前者在整个类中有效，后者在当前方法中有效）</p>
</li>
</ol>
<h3 id="8-API-字符串"><a href="#8-API-字符串" class="headerlink" title="8. API &amp; 字符串"></a>8. API &amp; 字符串</h3><ol>
<li><p>API: application programming interface: 应用程序编程接口。在java中，即jkd中提供的各种功能的java类。</p>
</li>
<li><p>如何使用帮助文档：i. 打开API帮助文档  ii. 点击显示，并找到索引下面的输入  iii. 在输入框中输入类名并点击显示  iv. 查看类所在的包</p>
</li>
<li><p>字符串的一般开发使用类：String，StringBuilder，StringJoiner, StringBuffer, Pattern, Matcher</p>
</li>
<li><p><strong>字符串的内容是不会发生改变的，他的对象在创建后不能被更改。但是变量赋值可以改变。</strong></p>
</li>
<li><p>创建字符串的两种方式：</p>
<p>i. 直接赋值。如String name &#x3D; “张三”，<strong>实际使用最多</strong></p>
<p>ii. new，调用构造函数。如new String(String original), new String(), new String(char[] chs), new String(byte[] chs) (此时会翻译为字母). <strong>后两者在实际开发中有相应应用。主要针对字符串内容无法修改，因此需要先将字符串转化为字符数组，修改后再重新转换位字符串</strong>。</p>
</li>
<li><p>字符串的内存占用：最早为<strong>串池</strong>，只有直接创建的字符串才会在串池中。从jdk7之后，<strong>串池被移动到堆内存中。</strong></p>
<p>直接赋值：首先在串池中查询是否存在该字符串，不存在则新建，<strong>存在则复用</strong>。</p>
<p>new：以字符数组为例，首先在堆内存中产生字符数组，随后在堆中开辟新创建字符串，随后赋值。<strong>不复用</strong>。</p>
</li>
<li><p>Java的常见方法（比较）</p>
<p><strong>&#x3D;&#x3D;的原理</strong>：如果&#x3D;&#x3D;两边是基本数据类型，则比较数据值；如果是引用数据类型，则比较地址值。</p>
<p>字符串比较内容的方法：</p>
<p>i. A.equals(B)     ii. A.equalsIgnoreCase(B) 后者忽略大小写</p>
</li>
<li><p>java键盘录入的字符串属于new的对象，因此与直接赋值得到的地址不同</p>
</li>
<li><p>A.charAt(i) 将字符串视为字符数组进行处理，就可以堆字符串进行遍历</p>
<p><strong>想要将1直接转换为字符1，最好直接使用字符串的拼接</strong></p>
</li>
<li><p>A.substring(0, 3)，包左不包右，截取字符串</p>
</li>
<li><p>A.replace(旧值, 新值)，字符串的替换。</p>
</li>
<li><p><strong>StringBuilder()</strong> 一个容器，创建之后里面的<strong>内容是可变</strong>的。<strong>作用：不会产生中间字符串，提高字符串的操作效率。</strong></p>
<p>原因：s1+s2+s3+s4+s5 每次相加都会产生一个中间字符串，影响程序的运行效率。</p>
<p>创建方法：</p>
<p>i. public StringBuilder() 创建一个空白可变字符串对象</p>
<p>ii. public StringBuilder(s0) 根据字符串创建对象</p>
<p>常用方法：</p>
<p>public StringBuilder append()</p>
<p>public StringBuilder reverse()</p>
<p>public int length();</p>
<p>public String toString()</p>
<p>不常用方法：</p>
<p>capacity() - 获取StringBuilder的容量</p>
<p><strong>因为StringBuilder是Java已经写好的类，所以java在底层对它进行了特殊处理，打印对象不是地址值而是属性值</strong></p>
<p><strong>StringBuilder的常用场景：</strong>翻转字符串；拼接字符串</p>
</li>
<li><p><strong>链式编程</strong>：当我们在调用一个方法的时候，不需要用变量接收它的结果，可以继续调用其他方法</p>
</li>
<li><p><strong>StringJoiner</strong>: StringJoiner sj &#x3D; new StringJoiner(“, “, “[“, “]”)。也是一个容器，创建后内容可变。</p>
<p>作用：提高字符串的操作效率，带你吗编写简介，但是在jdk8之后出现，因此用的人较少。</p>
<p>创建： public StringJoiner(间隔符号), 或 public StringJoiner(间隔符号, 开始符号, 结束符号)</p>
<p>常用方法：add, length, toString</p>
</li>
<li><p>jdk7及以前字符串拼接的底层原理：</p>
<p>i. 拼接时没有变量参与：如String s &#x3D; “a” + “b” + “c”, 触发字符串的优化机制，在编译的时候已经是最终结果了。即运行时可视为 String s &#x3D; “abc”</p>
<p>ii. 拼接时有变量参与：如String a1 &#x3D; “a”, String s &#x3D; s1 + “b”；内存中现在串池中创建”a”, 随后添加“b”，然后再内存中创建StringBuilder, 最后再通过toString转换为一个新的字符串”ab“，在堆内存中，但不在串池中。</p>
<p>jadk8字符串拼接的底层原理：</p>
<p>预估字符串长度，创建一个数组，分别存储各个变量，再将整体变为字符串。</p>
</li>
<li><p>StringBuilder源码分析：</p>
<p>i. 创建一个字符数组，默认容量为16。在StringBuilder中实际存储的是字符的ASCII表。</p>
<p>ii. 如果容量不够则扩容，新容量 &#x3D; 老容量*2+2. </p>
<p>iii. 如果超出扩容容量，则以实际容量为准</p>
</li>
</ol>
<h3 id="9-集合"><a href="#9-集合" class="headerlink" title="9. 集合"></a>9. 集合</h3><ol>
<li><p>集合产生原因：需要一个长度可变的容器</p>
</li>
<li><p>集合 - 只能存引用数据类型，不能存基本数据类型</p>
<p>数组 - 可以存基本数据类型，引用数据类型</p>
</li>
<li><p>泛型：用来限制数组中数据的类型，(api帮助文档中用<E>表示)</p>
<p>集合创建方式：</p>
<p>ArrayList<String> list &#x3D; new ArrayList&lt;&gt;(); (<strong>后面的泛型可省略</strong>)</p>
</li>
<li><p><strong>集合的成员方法（增删改查）</strong></p>
<p>add, remove, set, get, size</p>
</li>
</ol>
<h3 id="10-static"><a href="#10-static" class="headerlink" title="10. static"></a>10. static</h3><ol>
<li><p>static: <strong>所有类共享的对象</strong>，被static修饰的变量，甚至可以通过类名直接调用。可以修饰成员方法，也可以修饰成员变量</p>
<p>调用方式：i. 类名调用（推荐）   ii. 对象名调用</p>
<p>static内存图：在堆内存中单独开辟静态存储位置（<strong>静态区</strong>），存储该类所有的静态变量。</p>
<p><strong>静态变量随着类的加载而加载，优先于对象</strong></p>
</li>
<li><p>静态方法：被static修饰的成员方法。</p>
<p>特点：i. 多用在测试类和工具类中   ii. Javabean中很少会用</p>
<p><strong>工具类</strong>：可以帮助我们做一些事情，但是不描述任何事物。</p>
<p><strong>工具类需要私有化构造方法！！！</strong>原因：防止在外界创造该对象，因为创建该类毫无意义。如Math</p>
</li>
<li><p>static的注意事项：</p>
<p>i. 静态方法<strong>只能访问静态变量和静态方法</strong></p>
<p>ii. 非静态方法<strong>可以访问静态变量或者静态方法，也可以访问非静态的成员和方法</strong></p>
<p>iii. 静态方法中<strong>没有this</strong></p>
<p>内存角度解释：</p>
<p>i. jdk7之后，静态变量在静态区中，<strong>静态方法找变量的时候，只会在静态区中寻找，因此不能调用非静态变量（实例变量）</strong></p>
<p>ii. 对于非静态方法，由于静态方法无法找到调用者（this），因此不能调用非静态方法</p>
</li>
</ol>
<h3 id="11-继承"><a href="#11-继承" class="headerlink" title="11. 继承"></a>11. 继承</h3><ol>
<li><p><strong>继承</strong>：Java提供extends关键字，我们可以让一个类与另一个类建立起继承关系。</p>
<p>public class Student extends Person {}</p>
<p>Student称为子类，Person称为父类</p>
<p>优点：</p>
<p>i. 提高代码的复用性</p>
<p>ii. 子类可以在父类的基础上，增加新的功能，使得子类的功能更加强大</p>
</li>
<li><p><strong>什么时候用继承</strong>：类与类之间存在<strong>相同的内容</strong>，并满足<strong>子类是父类的一种</strong>，就可以考虑继承</p>
<p><strong>继承的特点</strong>：Java只支持单继承，不支持多继承，但支持多层继承。</p>
<p><strong>每一个类都直接或者间接的继承于Object</strong></p>
</li>
<li><p><strong>子类继承父类中的内容：</strong> </p>
<p>构造方法：均私有，<strong>都不能继承</strong></p>
<p>成员变量：都能被子类继承下来，<strong>但是私有部分不能直接调用，可以通过get和set进行操作</strong></p>
<p>成员方法：非私有（虚方法，非private, 非static, 非final）被继承下来，而私有被继承下来</p>
<p>内存图：</p>
<p>i. 子类的相应内存中，含有父类的私有变量，但是不能直接访问</p>
<p>ii. 从顶级父类开始，java设置虚方法表，储存可能被经常调用的方法。（非private, 非static, 非final）。虚方法表会继承给子类，子类也会添加自己新的虚方法</p>
</li>
<li><p>继承中的就近原则：</p>
<p>成员变量在使用时，首先在当前方法中寻找；当前方法中找不到，就在当前类中寻找；当前类中找不到，就在父类中寻找。</p>
<p>更精准的用法：当前方法内直接使用，当前类中使用时添加this.前缀，父类变量使用时添加super.前缀</p>
<p><strong>最多只能调用到父类的变量，不能调用到更高</strong></p>
<p><strong>就近原则针对this, super都是适用的</strong></p>
</li>
<li><p><strong>方法重写</strong>：当父类的方法不能满足子类现在的需求时，需要进行方法重写。</p>
<p>代码标志：子类中出现了和父类中一模一样的方法声明，<strong>在重写的方法上放@Override</strong>. </p>
<p><strong>方法重写的本质</strong>：在子类的虚方法表中发生覆盖</p>
<p>方法重写的注意事项：</p>
<p>i. 重写方法的名称、形参列表必须与父类中一致</p>
<p>ii. <strong>子类重写父类方法时，访问权限子类必须大于等于父类</strong>。（<strong>访问权限：public &gt; protected &gt; private</strong>）</p>
<p>iii. <strong>子类重写父类方法时，返回值类型子类必须小于等于父类</strong>。如存在继承关系Animinal-&gt;Dog, 只能父类返回Animinal，子类返回Dog，不能相反</p>
<p>iv. 重写方法尽量和父类保持一致</p>
<p>v. 只有被添加到虚方法表中的方法才能被重写</p>
</li>
<li><p><strong>继承中构造方法的访问特点</strong>：</p>
<p>i. 父类的构造方法不会被子类继承（否则与类名不一致），因此子类默认只有无参构造</p>
<p>ii. 子类中所有的构造方法默认线访问父类中的无参构造，再执行自己（因为需要完成父类数据空间的初始化）</p>
<p>iii. <strong>子类构造方法的第一行语句默认都是：super(), 不写也存在，且必须在第一行。如果想要调用父类的有参构造，必须手写super进行调用</strong></p>
</li>
<li><p>this, super使用总结</p>
<p>i. this: 理解为一个变量，表示当前方法调用者的地址值。<strong>在虚拟机眼中，this只是一个局部变量</strong></p>
<p>使用空参创造对象时，如果需要<strong>设置默认值</strong>，方法为：</p>
<p>this(null, 0, “电子科技大学”)</p>
<p>此时this相当于调用本类其他的构造方法，且虚拟机不再默认调用super()，因为其他类已经调用过了</p>
<p>ii. super: 代表父类存储空间</p>
</li>
</ol>
<h3 id="12-多态"><a href="#12-多态" class="headerlink" title="12. 多态"></a>12. 多态</h3><ol>
<li><p>多态：同类型的对象，表现出的不同形态。例：Person p &#x3D; new Student(); <strong>将子类赋值为父类的形态</strong></p>
<p>表现形式：父类类型 对象名称 &#x3D; 子类对象；</p>
<p>多态的前提：i. 有继承关系 ii. 有父类引用指向子类对象 iii. 有方法重写</p>
</li>
<li><p>作用：</p>
<p>例：register(Person p), 里面传入的参数可以是Student, Teacher或Administor, 同时里面调用的函数（如show）也会是对应类型的。</p>
</li>
<li><p>多态调用成员的特点：</p>
<p>主要针对：Animal a &#x3D; new Dog(); </p>
<p>i. 变量调用：编译看左边 ，运行也看左边。（即Javac编译代码的时候，会看左边的父类中有没有这个变量。如果有，则编译成功；反之，则编译失败。）</p>
<p>ii. 方法调用：编译看左边，运行看右边。（即Javac编译代码的时候，会看左边的父类中有没有这个方法。但是在运行的时候，如果子类进行了方法重写，则运行的是子类的方法。）</p>
<p>内存图解：</p>
<img src="D:\learning_programs\hexo_programs\mywebsite\source\_posts\images\java-tutorial\image-20230915170631761.png" alt="image-20230915170631761" style="zoom: 50%;" />
</li>
<li><p>多态的优势：</p>
<p>i. 在多态形式下，右边对象可以实现解耦合，便于扩展和维护。</p>
<p>ii. 定义方法的时候，使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利。例：对于所有对象，都可以用Object指代。 </p>
<p>多态的弊端：</p>
<p>不能调用子类的特有功能（解决方法：变回子类类型。如Dog d &#x3D; (Dog) a; <strong>这里不能随意转类型，比如将Dog转换为Cat</strong>。这里可以使用instanceof进行判断，对象是否属于相应的类。）</p>
<p>（jdk14之后提出新特性：a instanceof Cat d. 作用：如果a是Cat类型，则强转为Cat并赋值给d，否则不强转）</p>
</li>
</ol>
<h3 id="13-包与final"><a href="#13-包与final" class="headerlink" title="13. 包与final"></a>13. 包与final</h3><ol>
<li><p>包：即<strong>文件夹</strong>，用来管理各种不同功能的Java类，方便后期代码维护</p>
</li>
<li><p><strong>包名的规则</strong>：公司域名反写+包的作用，需要全部英文小写</p>
</li>
<li><p>在使用<strong>其他类</strong>时，需要使用<strong>全类名</strong>，如com.itheima.domain.Student()</p>
<p>为了避免使用的全类名过长，我们常常使用import，如import com.itheima.domain.Student</p>
</li>
<li><p>使用java.lang包中的类，或同一个包中的类时，不需要导包；如果使用两个包中的同名类，需要使用全类名</p>
</li>
<li><p>final：<strong>表示不可改变！！！</strong></p>
<p>可修饰对象：</p>
<p>i. 方法（表示该方法是最终方法，<strong>不能被重写</strong>） 一般用于一种规则</p>
<p>ii. 类（表示该类是最终类，<strong>不能被继承</strong>）</p>
<p>iii. 变量（此时可称为<strong>常量</strong>，<strong>只能被赋值一次</strong>）</p>
</li>
<li><p>常量注意事项：</p>
<p>i. 实际开发中，常量一般作为<strong>系统的配置信息</strong>，方便维护</p>
<p>ii. 常量的<strong>命名规范</strong>：单个单词-全部大写；多个单词-全部大写，中间用下划线分隔开</p>
<p>iii. final修饰的变量是基本数据类型时，则变量存储的<strong>数据值</strong>不能改变；</p>
<p>​	final修饰的变量时引用数据类型时，则变量存储的<strong>地址值</strong>不能改变，但是<strong>对象内部</strong>可以改变</p>
<p>​	综上，即<strong>在栈中存储的值是不可改变的</strong></p>
<p>iv. 以字符串为例，因为字符串的值定义中使用了private final byte[]，导致外部既无法获得地址，又无法修改数值，因此无法修改</p>
</li>
</ol>
<h3 id="14-权限修饰符和代码块"><a href="#14-权限修饰符和代码块" class="headerlink" title="14. 权限修饰符和代码块"></a>14. 权限修饰符和代码块</h3><ol>
<li><p>权限修饰符：用来控制一个成员能够<strong>被访问的范围</strong>，可修饰对象：变量，方法，构造方法，<strong>内部类</strong></p>
</li>
<li><p>四种权限修饰符：<strong>private &lt; 空着不写(缺省 &#x2F; 默认) &lt; protected &lt; public</strong></p>
<img src="D:\learning_programs\hexo_programs\mywebsite\source\_posts\images\java-tutorial\image-20231008213613772.png" alt="image-20231008213613772" style="zoom:50%;" />
</li>
<li><p>实际开发中，最常使用的时<strong>private和public</strong></p>
</li>
<li><p>代码块：{代码块}</p>
<p>代码块分类：局部代码块；构造代码块；静态代码块</p>
</li>
<li><p>i. 局部代码块：<strong>方法内的代码块</strong>. 作用：提前结束代码的生命周期（回收变量），但是现在一般不需要使用了</p>
<p>ii. 构造代码块：<strong>写在成员位置，优先于构造方法执行</strong>. 作用：用于构造方法的重复部分，现在也渐渐淘汰了，因为不够灵活</p>
<p>替代方法：</p>
<p>(1) 在一个构造方法中写入该代码块，然后在其他的构造方法中使用this(…)调用该代码块</p>
<p>(2) 将代码块写入新的函数中，通过调用函数实现</p>
<p>iii. <strong>静态代码块</strong>：在构造代码块的基础上，<strong>通过static关键字修饰，随着类的加载而加载，并且自动触发，只执行一次</strong></p>
<p>使用场景：在类加载的时候，用于数据初始化</p>
</li>
</ol>
<h3 id="15-抽象类"><a href="#15-抽象类" class="headerlink" title="15. 抽象类"></a>15. 抽象类</h3><ol>
<li><p>抽象方法：将<strong>共性的</strong>行为（<strong>方法</strong>）抽取到父类中，由于<strong>每一个子类执行的内容是不一样的</strong>，所以<strong>在父类中不能确定具体的方法体</strong>。</p>
<p>抽象类：如果一个<strong>类中存在抽象方法</strong>，那么该类就<strong>必须声明为抽象类</strong></p>
</li>
<li><p>定义格式：public abstract class 类名() {}</p>
</li>
<li><p>注意事项：</p>
<p>i. 抽象类<strong>不能实例化</strong></p>
<p>ii. 抽象类中<strong>不一定有抽象方法</strong>，有抽象方法的类一定是抽象类</p>
<p>iii. 抽象类<strong>可以有构造方法</strong> （作用：便利子类的构造）</p>
<p>iv. 抽象类的子类要么<strong>重写抽象类中的所有抽象方法</strong>，要么是<strong>抽象类</strong></p>
</li>
<li><p>抽象类和抽象方法的意义：<strong>强制</strong>子类按照规定的格式书写</p>
</li>
</ol>
<h3 id="16-接口"><a href="#16-接口" class="headerlink" title="16. 接口"></a>16. 接口</h3><ol>
<li><p>为什么有接口：整个体系中，<strong>部分个体</strong>具有的<strong>共性</strong>，属于一种<strong>规则</strong>，是对<strong>行为</strong>的抽象。如动物类中，可以定义拥有有用功能的接口。</p>
</li>
<li><p>定义格式：使用关键字interface来定义，public interface 接口{}</p>
<p>i. 接口<strong>不能实例化</strong></p>
<p>ii. 接口和类之间是实现的关系，通过implements关键字表示</p>
<p>iii. 接口的子类<strong>要么重写接口的所有类，要么是抽象类</strong></p>
<p>iv. 接口和类的实现关系，可以是<strong>单实现</strong>，也可以是<strong>多实现</strong></p>
<p>v. 实现类可以在继承一个类的同时，实现多个接口</p>
<p>vi. <strong>接口在定义之后，需要在内部定义对应的抽象方法！！！</strong></p>
</li>
<li><p>接口中成员的特点：</p>
<p>i. 成员变量 - 只能是<strong>常量</strong>，默认修饰符：<strong>public static final</strong></p>
<p>ii. 构造方法 - 没有(接口不能创造对象)</p>
<p>iii. 成员方法 - JDK7之前<strong>只能用抽象方法</strong></p>
</li>
<li><p>接口与类的关系</p>
<p>i. 类和类之间的关系：<strong>继承关系</strong>，只能单继承，不能多继承，但是可以多层继承</p>
<p>ii. 类与接口的关系: <strong>实现关系</strong>，可以但是先，也可以多实现，还可以在继承一个类的同时实现多个接口</p>
<p>​	多个接口中的抽象方法重名时，<strong>只需要重写一次即可</strong></p>
<p>iii. 接口和接口的关系：<strong>继承关系</strong>，可以单继承，也可以多继承。如果实现类实现了最下面的子接口，则需要重写所有的抽象方法</p>
</li>
<li><p>JDK8开始接口中新增方法：接口中可以定义有方法体的方法（<strong>默认，静态</strong>）；JDK9之后，接口中 可以定义<strong>私有方法</strong></p>
<p>原因：<strong>在JDK7中，如果接口发生变化，则所有实现类都要随之改变，否则报错，很不方便</strong>。 </p>
<p>解决方法：</p>
<p>i. JDK8中允许接口定义<strong>默认方法</strong>，需要使用关键字<strong>default</strong>修饰。定义格式：public default void show(){}</p>
<p>注意事项：</p>
<p>(1) 默认方法不是抽象方法，不强制被重写。但如果被重写，重写的时候去掉default关键字</p>
<p>(2) public可以省略，default不能省略</p>
<p>(3) 如果实现了多个接口，多个接口中存在相同名字的默认方法，<strong>子类就必须对该方法进行重写</strong></p>
<p>ii. <strong>静态方法</strong>：使用static进行修饰，定义格式：public static void show()</p>
<p>注意事项：</p>
<p>(1) 接口方法只能通过接口名调用，不能通过实现类名或者对象名调用</p>
<p>(2) public可以省略，static不能省略</p>
<p>(3) <strong>不能重写！！！</strong></p>
<p>iii. <strong>私有方法</strong>：接口中需要抽取重复代码时，就可以使用private。原因：这些方法只希望本接口使用，而不希望被外部引用</p>
<p>格式1：private void show(){} （<strong>为默认方法服务</strong>）</p>
<p>格式2：private static void show(){} (<strong>为静态方法服务</strong>)</p>
</li>
<li><p>接口的应用：</p>
<p>i. 将多个类都可能用到的规则定义为接口</p>
<p>ii. <strong>接口的多态</strong>：<strong>使用接口作为方法的传入参数，就可以传入任何实现了该接口的对象</strong></p>
</li>
<li><p><strong>设计模式</strong>(Design pattern)：一套被反复使用，多数人知晓，经过分类编目的、代码设计经验的总结。</p>
<p>使用设计模式，是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性</p>
<p><strong>适配器设计模式</strong>：解决接口与接口实现类之间的矛盾问题。例：对于接口Inter，首先设计实现类InterAdapter（<strong>一般设置为抽象类abstract</strong>）, 所有实现方法为空；随后使用的实现类InterImpl，就只需要继承类InterAdapter, 然后再重写自己需要的类即可。</p>
<p>如果此时实现类需要继承其他类，<strong>只需要重新设计适配器，多层继承即可</strong></p>
</li>
</ol>
<h3 id="17-内部类"><a href="#17-内部类" class="headerlink" title="17. 内部类"></a>17. 内部类</h3><ol>
<li><p>类的<strong>五大成员</strong>：属性，方法，构造方法，代码块，内部类</p>
</li>
<li><p>内部类：在一个类的内部，再定义一个类</p>
</li>
<li><p>内部类的访问特点：</p>
<p>i. 内部类可以直接访问外部类的成员，<strong>包括私有</strong></p>
<p>ii. 外部类要访问内部类的成员，<strong>必须创建对象</strong></p>
</li>
<li><p>使用场景：B类表示的事物是A类的一部分，且B单独存在没有意义</p>
</li>
<li><p>内部类的分类：</p>
<p>i. 成员内部类 - 写在成员位置，属于外部类的成员，可以被修饰符修饰，如private, 默认, protected等</p>
<img src="D:\learning_programs\hexo_programs\mywebsite\source\_posts\images\java-tutorial\image-20231009103309534.png" alt="image-20231009103309534" style="zoom:50%;" />

<p>获取成员内部类对象：</p>
<p>(1) <strong>使用外部类的对象进行调用</strong>：Outer.Inner oi &#x3D; new Outer().new Inner();</p>
<p>(2) <strong>对于私有化的内部类，可以编写getInstance方法进行创建</strong></p>
<p>成员变量获取外部类变量的方法：</p>
<img src="D:\learning_programs\hexo_programs\mywebsite\source\_posts\images\java-tutorial\image-20231009105355122.png" alt="image-20231009105355122" style="zoom:50%;" />

<p>在内部类中，会存储一个Outer.this(具体名称)，来代表外部类对象的地址值</p>
<p>ii. 静态内部类 - <strong>成员内部类的一种，使用static修饰</strong>。只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要创建对象。</p>
<p>创建格式：外部类名.内部类名 对象名 &#x3D; new 外部类名.内部类名（）；</p>
<p>调用非静态方法：先创建对象，用对象调用</p>
<p>调用静态方法：外部类名.内部类名.方法名</p>
<p>iii. 局部内部类 - 将内部类定义在<strong>方法内部</strong>。</p>
<p>注意事项：</p>
<p>(1) 外界无法直接使用，需要在方法内部创建对象并使用</p>
<p>(2) 该类可以直接访问外部类的成员，也可以访问方法内的局部变量</p>
<p>iv. <strong>匿名内部类</strong></p>
<p>本质：隐藏了名字的内部类</p>
<img src="D:\learning_programs\hexo_programs\mywebsite\source\_posts\images\java-tutorial\image-20231009111558286.png" alt="image-20231009111558286" style="zoom:50%;" /></li>
</ol>
<h3 id="18-游戏打包exe"><a href="#18-游戏打包exe" class="headerlink" title="18. 游戏打包exe"></a>18. 游戏打包exe</h3><ol>
<li><p>游戏打包exe要考虑的因素</p>
<ul>
<li>一定要包含<strong>图形化界面</strong></li>
<li><strong>代码</strong>要打包起来</li>
<li><strong>游戏用到的图片</strong>也要打包</li>
<li><strong>jdk</strong>也要打包</li>
</ul>
</li>
<li><p>游戏打包的核心步骤</p>
<p>i. 将所有代码打包成一个压缩包，<strong>jar</strong>后缀的压缩包</p>
<p>ii. 把jar包<strong>转换成exe</strong>安装包</p>
<p>iii. 将第二步的<strong>exe，图片，jdk</strong>整合在一起，变成最终的exe安装包</p>
</li>
<li><p>exe4j仅支持jdk8-11，但jdk14之后可以考虑直接使用jpackage</p>
</li>
</ol>
<h3 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="*IDEA快捷键"></a>*IDEA快捷键</h3><ol>
<li><p>psvm: public static void main(String[] args);</p>
</li>
<li><p>sout: System.out.println();</p>
</li>
<li><p>fori：构建for(int i&#x3D;0, i&lt; ; i++)循环体</p>
</li>
<li><p>构造类的时候的快捷键：alt+insert (或alt+fn+insert)。可以选择构造函数，set和get</p>
</li>
<li><p>插件PTG 1s生成Javabean: 右键生成Javabean</p>
</li>
<li><p>对于java自带的类，只需要在idea中输入一部分并按回车，就会自动补全import部分</p>
</li>
<li><p>使用鼠标滚轮，可以竖着对idea中的代码进行选择</p>
</li>
<li><p>导入包时，需要选择iml文件，而不是文件夹</p>
</li>
<li><p>ctrl + shift + u: 大写</p>
</li>
<li><p>alt+enter: 对红色波浪线部分进行修正</p>
</li>
<li></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java-tutorial/" rel="tag"># java tutorial</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/10/28/c-tutorial/" rel="prev" title="c++ tutorial">
                  <i class="fa fa-angle-left"></i> c++ tutorial
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">windbro</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
