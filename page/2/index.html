<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="windbro的小黑屋">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="windbro的小黑屋">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="windbro">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>windbro的小黑屋</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">windbro的小黑屋</h1>
      <i class="logo-line"></i>
    </a>
      <img class="custom-logo-image" src="/images/logo.jpg" alt="windbro的小黑屋">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">windbro</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/28/java-tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windbro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windbro的小黑屋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | windbro的小黑屋">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/28/java-tutorial/" class="post-title-link" itemprop="url">java tutorial</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-28 19:48:58" itemprop="dateCreated datePublished" datetime="2023-10-28T19:48:58+08:00">2023-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-07 11:57:19" itemprop="dateModified" datetime="2023-12-07T11:57:19+08:00">2023-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/code-tutorial/" itemprop="url" rel="index"><span itemprop="name">code-tutorial</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-入门知识"><a href="#1-入门知识" class="headerlink" title="1. 入门知识"></a>1. 入门知识</h3><ol>
<li><p>环境变量Path：相当于在电脑中存储一些路径，因此在cmd命令界面中，不需要进入到相对应的路径中即可。</p>
</li>
<li><p>bin-存放各种工具命令，如javac和java；conf：存放相关配置文件；include：存放特定的头文件；jmods：存放各种模块；legl:存放各种授权文件；lib-存放工具的一些补充JAR包</p>
</li>
<li><p>程序运行分为两步：<strong>编译</strong>（javac xxx.java）；<strong>执行</strong>（java xxx），执行的时候不需要后缀</p>
</li>
<li><p>Java SE：java语言的标准版，用于桌面应用的开发，是其他两个版本的<strong>基础</strong>。（但是并不合适，常见的是C和C++）</p>
<p>Java ME：java语言的小型版，用于嵌入式电子设备和小型移动设备（已凉）</p>
<p>Java EE：java语言的企业版，用于Web方向的网站开发。网站开发分为浏览器+服务器，java主要用于后者（主力）</p>
</li>
<li><p>java优点：面向对象；安全性（代码漏洞少）；多线程；简单易用；开源；跨平台（指操作系统，Windows, Mac, Linux）</p>
</li>
<li><p>编译型语言(c, c++)：整体翻译；解释型语言（python）：逐行翻译。</p>
<p>混合型语言(java)：首先整体编译为.class二进制字节码文件，再按行交给设备运行（运行在<strong>虚拟机</strong>中）。java不直接运行在操作系统中，而是在虚拟机中，这就是java能够多平台运行的原因</p>
</li>
<li><p>JVM: java virtual machine, java虚拟机；  核心类库：java预先定义的内容</p>
<p>javac：编译工具；java：运行工具；jdb 调试工具；jhat 内存分析工具</p>
</li>
</ol>
<p>​		JDK：java开发工具，包含JVM, 核心类库，核心类库，开发工具；</p>
<p>​		JRE: java运行环境，包含JVM， 核心类库，运行工具</p>
<h3 id="2-小概念"><a href="#2-小概念" class="headerlink" title="2. 小概念"></a>2. 小概念</h3><ol>
<li><p>注释 - 单行注释&#x2F;&#x2F;， 多行注释&#x2F;* <em>&#x2F;，文档注释 &#x2F;</em>* *&#x2F;，主要用于说明文档 ; </p>
</li>
<li><p>关键字：被java赋予<strong>特定含义</strong>的英文单词。特点：关键字的字母全部<strong>小写</strong>；常用的代码编译器，会将关键字用<strong>特殊颜色</strong>标出。举例：</p>
<p>class: 用于创建或定义一个类，是java最基本的组成单元</p>
</li>
<li><p>字面量：主要用于告诉程序员，数据在程序中的书写格式。如：整数和小数类型；字符串类型和字符类型（前者需要“”， 后者需要’’）；布尔类型(true, false)和空类型（null）</p>
<p>常见特殊字符：\t, 制表符，在打印的时候吧前面字符串的长度补齐到8或8的倍数，最少补1个空格，最多补8个空格</p>
</li>
<li><p>变量：在程序中可能会改变的量。定义格式：数据类型 变量名 &#x3D; 数据值；</p>
<p>变量注意事项：i. 只能存一个值；ii. 变量名不允许重复； iii. 一条语句可以定义多个变量； iv: 变量<strong>使用前一定要赋值</strong>； v: 变量要注意<strong>作用范围</strong></p>
</li>
<li><p><strong>类名一定要与文件名统一！！！</strong></p>
</li>
<li><p>计算机的存储规律：主要分为文本、图片、声音三类，但是都是以二进制的形式来存储。</p>
<p>计算机中各种进制的表型形式：二进制 - 0b；十进制 - 无前缀；八进制  - 0； 十六进制 - 0x；</p>
</li>
<li><p>数据类型：基本数据类型+引用数据类型。基本数据类型：整数（byte, short, int, long）；浮点数（float, double）；字符（char）;布尔类型（boolean）</p>
</li>
<li><p>标识符：给类、方法、变量起的名字。</p>
<p>硬性要求：</p>
<p>i. 有数字、字母、下划线_、美元$构成</p>
<p>ii. 不能以数字开头</p>
<p>iii. 不能是关键字</p>
<p>iv. 区分大小写</p>
<p>软性建议：</p>
<p>i. 小驼峰命名法：一个单词时全部小写（name），多个单词时第一个单词首字母小写，后续的单词首字母大写(nameFirst) 。<strong>主要用于方法、变量</strong></p>
<p>ii. 大驼峰命名法：一个或多个单词组成时，全部单词首字母大写。<strong>主要用于类名</strong></p>
<p>iii. <strong>见名知意</strong></p>
</li>
<li><p>键盘录入<strong>Scanner</strong>类，可以接受键盘输入的<strong>数字</strong>。</p>
<p>使用步骤：</p>
<p>i. 导包(import java.util.Scanner)；</p>
<p>ii. 创建对象(Scanner sc &#x3D; new Scanner(System.in))；</p>
<p>iii. 接受数据(int i &#x3D; sc.nextInt())</p>
<p><strong>Scanner的两套体系：</strong></p>
<p>第一套体系（空格，制表符或回车 停止接收）：</p>
<p>i. nextInt() : 接收整数</p>
<p>ii. nextDouble() : 接收小数</p>
<p>iii. next() : 接收字符串</p>
<p>第二套体系（仅停车 停止接收，其余皆可）：</p>
<p>i. nextLine() : 接收字符串</p>
</li>
<li><p>IDEA项目结构：project(项目)；module（模块）；package（包）；class（类）</p>
<p>对于包package，使用时常常创建多级包，用来表示所属关系。如com.itheima.demo1</p>
</li>
</ol>
<h3 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h3><ol>
<li>隐式转换（自动类型提升）：将取值范围小的数值，转换为取值范围大的数值。char, short, byte类型都会先转换为int类型，之后再参与计算</li>
<li>强制装换：将一个取值范围大的数值，赋值给取值给取值范围小的数值。（强制转换的优先级比较低，最好在后面添加小括号）</li>
<li>字符串相加：+操作中出现字符串时，此时相当于字符串的拼接，产生一个新的字符串。如：“123”+123 &#x3D; “123123”。连续+号，从左到右逐个进行</li>
<li>字符相加：先提升为int，再进行计算</li>
<li>java中包含自增运算符++和自减运算符–</li>
<li>逻辑运算符：&amp; | ^ ! ; 短路运算符：&amp;&amp; || 用于提高程序运行效率，只要能够判断结果，就不再继续向后运算。</li>
<li>三元运算符：A?B:C ;</li>
</ol>
<h3 id="4-流程控制语句"><a href="#4-流程控制语句" class="headerlink" title="4. 流程控制语句"></a>4. 流程控制语句</h3><ol>
<li><p>三种控制语句：顺序结构；分支结构；循环结构</p>
</li>
<li><p>if语句：</p>
<p>第一种格式：if(关系表达式){语句体;}</p>
<p>第二种格式：if(关系表达式){语句体;} else {语句体;}</p>
<p>第三种格式：if(关系表达式){语句体;} else if(关系表达式){语句体} … else {语句体}</p>
<p>switch语句：switch(表达式){case 值1: 语句体; break; case 值2: 语句体; break; default: 语句体; break;}</p>
<p>如果每个case语句后面只有一个执行语句，也可以这样：</p>
<p>switch(表达式){case 值1 -&gt; 语句体; case 值2 -&gt; 语句体; … default -&gt; 语句体}</p>
<p>switch(表达式){case 值1,2,3 -&gt; 语句体; case 值4, 5 -&gt; 语句体}</p>
</li>
<li><p>switch其他知识</p>
<p>i. default的位置和省略：default可以省略，此时如果不匹配则无执行内容； default需要设置在最后</p>
<p>ii. case的穿透：case如果匹配且后面无break，就会向下继续执行（可以用于case语句重复时的简化代码，如周1-4是工作日，周5-7是休息日）</p>
</li>
<li><p>for循环：</p>
<p>for(int i&#x3D;1; i&lt;&#x3D; 10; i++) { … }</p>
<p>while循环：</p>
<p>while(i&lt;10) { … }</p>
<p>do … while循环：</p>
<p>do { … } while { … }</p>
</li>
<li><p>break, continue语句：不解释</p>
</li>
<li><p>生成随机数：import java.util.Random; Random r &#x3D; new Random(); int num &#x3D; r.nextInt(100) (小括号内写的，是随机数的范围，以0开始，给定数-1为阶数);;</p>
</li>
</ol>
<h3 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h3><ol>
<li><p>数组：用于存储同种数据类型的多个值</p>
</li>
<li><p>定义方式：</p>
<p>i. 数组类型[] 数组名， 如：int[] array;（更常用） </p>
<p>ii. 数据类型 数组名[]，如：int array[];</p>
</li>
<li><p>数组的初始化：</p>
<p>静态初始化：int[] array &#x3D; new int[] {1, 2, 3, 4, 5}。<strong>注意：没有float类型的数组，一般小数默认为double类型！</strong></p>
<p>​						简写格式：int[] array &#x3D; {1, 2, 3, 4, 5};</p>
<p>动态初始化：int[] array &#x3D; new int[50]; <strong>注意：动态初始化时，new后面的数组长度可以是变量</strong></p>
<p>​						对于动态初始化，整数默认为0，小数默认为0.0，字符默认为’&#x2F;u0000’，即空格，布尔默认为false，引用默认为null</p>
</li>
<li><p>数组打印：直接打印arr，得到的是数组的地址值。实际打印采用：arr[10]类型格式</p>
</li>
<li><p>数组遍历：arr.length为数组的长度，随后for循环即可遍历。</p>
<p>​					简写方法：for(int num : arr) { … } 这时的缺点在于，不知道此时遍历元素的索引。</p>
</li>
<li><p><strong>java内存分配：</strong>主要分为五部分：栈，堆，方法区，本地方法栈，寄存器。</p>
<p>栈：<strong>方法</strong>运行时使用的内存，如main方法运行，进入方法栈中执行</p>
<p>堆：存储<strong>对象或者数组</strong>，new来创建的东西在该块内存中开辟空间并产生地址 。<strong>比如a&#x3D;10这样的语句，没有使用new，因此不适用堆空间，而是在栈内存！！！</strong></p>
<p>方法区：存储可以运行的<strong>class文件</strong></p>
<p>本地方法栈：JVM在使用操作系统功能时使用，与开发过程无关</p>
<p>寄存器：与CPU相关</p>
</li>
<li><p>常用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int[] arr_orig = &#123;0, 1, 2, 3, 4, 5, 6&#125;</span><br><span class="line"></span><br><span class="line">// copyOfRange, 将原数组的[start:end)的数据拷贝到新数组</span><br><span class="line">int[] arr = Arrays.copyOfRange(arr_orig, 1, 3);</span><br><span class="line"></span><br><span class="line">// copyOf, 将原数组复制到新数组从0开始的位置，然后更多的长度用默认值代替</span><br><span class="line">int[] arr = Arrays.copyOf(arr_orig, 10);</span><br><span class="line"></span><br><span class="line">// arraycopy, 最自由的方法，将原数组指定长度的数组拷贝到目标数组的指定长度</span><br><span class="line">arraycopy(arr_orig, 0, arr, 1, 3)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="6-方法"><a href="#6-方法" class="headerlink" title="6. 方法"></a>6. 方法</h3><ol>
<li><p>方法(method)是程序中<strong>最小的执行单元</strong>，要么全部执行，要么不执行。对于<strong>重复的代码、具有独立功能的代码</strong>，可以抽取到方法中。优点：提高代码的复用性、可维护性。</p>
</li>
<li><p>方法定义：</p>
<p>public static void 方法名(参数类型 参数, ….) {方法体; return 返回值}</p>
</li>
<li><p>形参：<strong>方法定义</strong>中的参数；</p>
<p>实参：实际参数，<strong>方法调用</strong>中的参数</p>
</li>
<li><p>方法注意事项：</p>
<p>i. 方法与方法之间是平级关系，不能互相嵌套</p>
<p>ii. 方法的编写顺序与执行顺序无关</p>
</li>
<li><p>方法重载</p>
<p>在同一个类中，定义了多个<strong>同名的方法</strong>，这样方法有<strong>同种的功能</strong>，但是具有<strong>不同的参数类型</strong>或者<strong>参数个数</strong>。</p>
<p><strong>方法重载的参数值必须是相同的，否则就是两个不同的方法，不能同名</strong></p>
<p>参数不同分为三种：个数不同，类型不同，顺序不同</p>
</li>
<li><p>基本数据类型：整数、浮点数、布尔、字符（变量中存储的是<strong>真实数据</strong>）</p>
<p>引用数据类型：例如array（使用new创建的，都是引用数据类型，在<strong>堆</strong>中开辟空间。变量在栈中记录的是地址，在堆中记录的是数据）</p>
</li>
<li><p><strong>在java中，如果传递的是基本数据类型，形参的改变不影响实参的值。</strong></p>
<p><strong>如果传递的是引用数据类型（如数据），此时传递的是地址值，因此会改变实参的值。</strong></p>
</li>
</ol>
<h3 id="7-面向对象"><a href="#7-面向对象" class="headerlink" title="7. 面向对象"></a>7. 面向对象</h3><ol>
<li><p>面向对象编程：通过获取<strong>特定对象</strong>来完成任务</p>
</li>
<li><p>面向对象学习什么：</p>
<p>i. 获取已有对象并使用</p>
<p>ii. 自己设计对象并使用</p>
</li>
<li><p>类：对象共同特征的描述。（相当于设计图）</p>
<p>对象：真实存在的具体物体。</p>
<p>类的组成：成员变量；成员方法；构造器；代码块；内部类。</p>
<p>对象的定义：类名 对象名 &#x3D; new 类名();</p>
<p>对象的调用：<strong>对象.成员变量</strong>； 对象.成员方法</p>
</li>
<li><p>定义类的补充注意事项：</p>
<p>Javabean类：用于描述一类事物的类，不写main函数</p>
<p>测试类：可以创建javabean类的对象并进行赋值使用</p>
<p>i. 类名首字母大写，使用<strong>大驼峰命名法</strong></p>
<p>ii. 一个java文件中可以定义多个class类，<strong>但只能一个类是public修饰，且该类名必须称为代码文件名</strong>。在实际开发中，<strong>一个文件尽量定义一个class类</strong></p>
<p>iii. 成员变量的完整定义格式：<strong>修饰符 数据类型 变量名称 &#x3D; 初始化值</strong>；一般无需指定初始化值，存在默认值。</p>
</li>
<li><p><strong>开发中类的设计</strong>：一般来说，名词设计为类，动词设计为类对应的方法。</p>
</li>
<li><p><strong>面向对象的三大特征：封装，继承，多态</strong></p>
<p><strong>封装</strong>：如何正确设计对象的属性和方法。对象代表什么，就得封装对应的数据，并提供数据对应的行为。<strong>简单来说，以人关门为例，门自身具有一个状态（开关），对该状态改变的方法就属于人</strong></p>
</li>
<li><p><strong>private</strong>：是一个权限修饰符，可以修饰成员（成员变量和成员方法），<strong>只能在本类中访问</strong>。</p>
<p>作用：使代码更健壮、安全（如age需要代表的范围）。</p>
<p>常用方法：设置属性为private，但是设置public void setAge, public int getAge.</p>
<p><strong>对于每个私有化的成员变量，都要提供get和set方法</strong></p>
</li>
<li><p>就近原则：在类的方法内和方法外的变量同名时，使用该变量会就行</p>
</li>
<li><p><strong>构造方法</strong>：也叫构造器，构造函数。</p>
<p>作用：在创建变量时，给成员变量进行赋值。</p>
<p>格式：修饰符 类名（参数）{方法体；}</p>
<p>特点：</p>
<p>i. 方法名与类名相同，大小写一致</p>
<p>ii. 没有返回值类型，连void都没有</p>
<p>iii. 没有返回值，因此不能有return</p>
<p>执行时机：</p>
<p>创建对象时有虚拟机调用， 不能手动调用；每创建一个对象，就调用一次。</p>
<p><strong>一般来说，我们在创建类时，还是会写空参构造。因为在写了有参构造后，虚拟机就不再自动生成无参构造</strong></p>
</li>
<li><p>注意事项</p>
<p>i. 未定义构造方法时，系统会构造默认的午餐构造</p>
<p>ii.构造函数的重构。方法名相同，参数不同</p>
<p>iii. <strong>一般来说，我们至少要写两个构造方法：无参构造方法和带全部参数的构造方法</strong></p>
<p>iv. 调用构造方法知识创造对象的一部分，而不是全部。构造方法的作用：给成员变量进行初始化</p>
</li>
<li><p>标准JavaBean注意事项：</p>
<p>i. 类名见名知意</p>
<p>ii. <strong>成员变量使用private修饰</strong></p>
<p>iii. 至少有两个构造方法：午餐构造和带全部参数的构造</p>
<p>iv. 要构造setXxx和getXxx</p>
</li>
<li><p>原空间：字节码文件时，进入的内存</p>
<p>栈内存：方法运行时进入的内存，变量也是在这里</p>
<p>堆：new创建的对象</p>
<p>一个对象的内存图：（以 Student s &#x3D; new Student();为例）加载class文件；申明局部变量；在堆内存中开辟一个空间；默认初始化；显示初始化；构造方法初始化；将堆内存中的地址值赋 值给左边的局部变量。</p>
</li>
<li><p>this的内存原理：菊粉局部变量和成员变量。this的本质：所在方法调用者的地址</p>
</li>
<li><p>成员变量：类中方法外的变量</p>
<p>局部变量：方法中的变量</p>
<p>区别：</p>
<p>类中位置不同（前者在类中方法外，后者在方法内）；</p>
<p>初始化值不同（前者有默认初始化值，后者没有，需要赋值）</p>
<p>内存位置不同（前者在堆内存中，后者在栈内存中）</p>
<p>生命周期不同（前者随着对象的创建而存在，随着对象的消失而消失；后者随着方法的调用而存在，随着方法的运行结束而消失）</p>
<p>作用域不同（前者在整个类中有效，后者在当前方法中有效）</p>
</li>
</ol>
<h3 id="8-API-字符串"><a href="#8-API-字符串" class="headerlink" title="8. API &amp; 字符串"></a>8. API &amp; 字符串</h3><ol>
<li><p>API: application programming interface: 应用程序编程接口。在java中，即jkd中提供的各种功能的java类。</p>
</li>
<li><p>如何使用帮助文档：i. 打开API帮助文档  ii. 点击显示，并找到索引下面的输入  iii. 在输入框中输入类名并点击显示  iv. 查看类所在的包</p>
</li>
<li><p>字符串的一般开发使用类：String，StringBuilder，StringJoiner, StringBuffer, Pattern, Matcher</p>
</li>
<li><p><strong>字符串的内容是不会发生改变的，他的对象在创建后不能被更改。但是变量赋值可以改变。</strong></p>
</li>
<li><p>创建字符串的两种方式：</p>
<p>i. 直接赋值。如String name &#x3D; “张三”，<strong>实际使用最多</strong></p>
<p>ii. new，调用构造函数。如new String(String original), new String(), new String(char[] chs), new String(byte[] chs) (此时会翻译为字母). <strong>后两者在实际开发中有相应应用。主要针对字符串内容无法修改，因此需要先将字符串转化为字符数组，修改后再重新转换位字符串</strong>。</p>
</li>
<li><p>字符串的内存占用：最早为<strong>串池</strong>，只有直接创建的字符串才会在串池中。从jdk7之后，<strong>串池被移动到堆内存中。</strong></p>
<p>直接赋值：首先在串池中查询是否存在该字符串，不存在则新建，<strong>存在则复用</strong>。</p>
<p>new：以字符数组为例，首先在堆内存中产生字符数组，随后在堆中开辟新创建字符串，随后赋值。<strong>不复用</strong>。</p>
</li>
<li><p>Java的常见方法（比较）</p>
<p><strong>&#x3D;&#x3D;的原理</strong>：如果&#x3D;&#x3D;两边是基本数据类型，则比较数据值；如果是引用数据类型，则比较地址值。</p>
<p>字符串比较内容的方法：</p>
<p>i. A.equals(B)     ii. A.equalsIgnoreCase(B) 后者忽略大小写</p>
</li>
<li><p>java键盘录入的字符串属于new的对象，因此与直接赋值得到的地址不同</p>
</li>
<li><p>A.charAt(i) 将字符串视为字符数组进行处理，就可以堆字符串进行遍历</p>
<p><strong>想要将1直接转换为字符1，最好直接使用字符串的拼接</strong></p>
</li>
<li><p>A.substring(0, 3)，包左不包右，截取字符串</p>
</li>
<li><p>A.replace(旧值, 新值)，字符串的替换。</p>
</li>
<li><p><strong>StringBuilder()</strong> 一个容器，创建之后里面的<strong>内容是可变</strong>的。<strong>作用：不会产生中间字符串，提高字符串的操作效率。</strong></p>
<p>原因：s1+s2+s3+s4+s5 每次相加都会产生一个中间字符串，影响程序的运行效率。</p>
<p>创建方法：</p>
<p>i. public StringBuilder() 创建一个空白可变字符串对象</p>
<p>ii. public StringBuilder(s0) 根据字符串创建对象</p>
<p>常用方法：</p>
<p>public StringBuilder append()</p>
<p>public StringBuilder reverse()</p>
<p>public int length();</p>
<p>public String toString()</p>
<p>不常用方法：</p>
<p>capacity() - 获取StringBuilder的容量</p>
<p><strong>因为StringBuilder是Java已经写好的类，所以java在底层对它进行了特殊处理，打印对象不是地址值而是属性值</strong></p>
<p><strong>StringBuilder的常用场景：</strong>翻转字符串；拼接字符串</p>
</li>
<li><p><strong>链式编程</strong>：当我们在调用一个方法的时候，不需要用变量接收它的结果，可以继续调用其他方法</p>
</li>
<li><p><strong>StringJoiner</strong>: StringJoiner sj &#x3D; new StringJoiner(“, “, “[“, “]”)。也是一个容器，创建后内容可变。</p>
<p>作用：提高字符串的操作效率，带你吗编写简介，但是在jdk8之后出现，因此用的人较少。</p>
<p>创建： public StringJoiner(间隔符号), 或 public StringJoiner(间隔符号, 开始符号, 结束符号)</p>
<p>常用方法：add, length, toString</p>
</li>
<li><p>jdk7及以前字符串拼接的底层原理：</p>
<p>i. 拼接时没有变量参与：如String s &#x3D; “a” + “b” + “c”, 触发字符串的优化机制，在编译的时候已经是最终结果了。即运行时可视为 String s &#x3D; “abc”</p>
<p>ii. 拼接时有变量参与：如String a1 &#x3D; “a”, String s &#x3D; s1 + “b”；内存中现在串池中创建”a”, 随后添加“b”，然后再内存中创建StringBuilder, 最后再通过toString转换为一个新的字符串”ab“，在堆内存中，但不在串池中。</p>
<p>jadk8字符串拼接的底层原理：</p>
<p>预估字符串长度，创建一个数组，分别存储各个变量，再将整体变为字符串。</p>
</li>
<li><p>StringBuilder源码分析：</p>
<p>i. 创建一个字符数组，默认容量为16。在StringBuilder中实际存储的是字符的ASCII表。</p>
<p>ii. 如果容量不够则扩容，新容量 &#x3D; 老容量*2+2. </p>
<p>iii. 如果超出扩容容量，则以实际容量为准</p>
</li>
</ol>
<h3 id="9-集合"><a href="#9-集合" class="headerlink" title="9. 集合"></a>9. 集合</h3><ol>
<li><p>集合产生原因：需要一个长度可变的容器</p>
</li>
<li><p>集合 - 只能存引用数据类型，不能存基本数据类型</p>
<p>数组 - 可以存基本数据类型，引用数据类型</p>
</li>
<li><p>泛型：用来限制数组中数据的类型，(api帮助文档中用<E>表示)</p>
<p>集合创建方式：</p>
<p>ArrayList<String> list &#x3D; new ArrayList&lt;&gt;(); (<strong>后面的泛型可省略</strong>)</p>
</li>
<li><p><strong>集合的成员方法（增删改查）</strong></p>
<p>add, remove, set, get, size</p>
</li>
</ol>
<h3 id="10-static"><a href="#10-static" class="headerlink" title="10. static"></a>10. static</h3><ol>
<li><p>static: <strong>所有类共享的对象</strong>，被static修饰的变量，甚至可以通过类名直接调用。可以修饰成员方法，也可以修饰成员变量</p>
<p>调用方式：i. 类名调用（推荐）   ii. 对象名调用</p>
<p>static内存图：在堆内存中单独开辟静态存储位置（<strong>静态区</strong>），存储该类所有的静态变量。</p>
<p><strong>静态变量随着类的加载而加载，优先于对象</strong></p>
</li>
<li><p>静态方法：被static修饰的成员方法。</p>
<p>特点：i. 多用在测试类和工具类中   ii. Javabean中很少会用</p>
<p><strong>工具类</strong>：可以帮助我们做一些事情，但是不描述任何事物。</p>
<p><strong>工具类需要私有化构造方法！！！</strong>原因：防止在外界创造该对象，因为创建该类毫无意义。如Math</p>
</li>
<li><p>static的注意事项：</p>
<p>i. 静态方法<strong>只能访问静态变量和静态方法</strong></p>
<p>ii. 非静态方法<strong>可以访问静态变量或者静态方法，也可以访问非静态的成员和方法</strong></p>
<p>iii. 静态方法中<strong>没有this</strong></p>
<p>内存角度解释：</p>
<p>i. jdk7之后，静态变量在静态区中，<strong>静态方法找变量的时候，只会在静态区中寻找，因此不能调用非静态变量（实例变量）</strong></p>
<p>ii. 对于非静态方法，由于静态方法无法找到调用者（this），因此不能调用非静态方法</p>
</li>
</ol>
<h3 id="11-继承"><a href="#11-继承" class="headerlink" title="11. 继承"></a>11. 继承</h3><ol>
<li><p><strong>继承</strong>：Java提供extends关键字，我们可以让一个类与另一个类建立起继承关系。</p>
<p>public class Student extends Person {}</p>
<p>Student称为子类，Person称为父类</p>
<p>优点：</p>
<p>i. 提高代码的复用性</p>
<p>ii. 子类可以在父类的基础上，增加新的功能，使得子类的功能更加强大</p>
</li>
<li><p><strong>什么时候用继承</strong>：类与类之间存在<strong>相同的内容</strong>，并满足<strong>子类是父类的一种</strong>，就可以考虑继承</p>
<p><strong>继承的特点</strong>：Java只支持单继承，不支持多继承，但支持多层继承。</p>
<p><strong>每一个类都直接或者间接的继承于Object</strong></p>
</li>
<li><p><strong>子类继承父类中的内容：</strong> </p>
<p>构造方法：均私有，<strong>都不能继承</strong></p>
<p>成员变量：都能被子类继承下来，<strong>但是私有部分不能直接调用，可以通过get和set进行操作</strong></p>
<p>成员方法：非私有（虚方法，非private, 非static, 非final）被继承下来，而私有被继承下来</p>
<p>内存图：</p>
<p>i. 子类的相应内存中，含有父类的私有变量，但是不能直接访问</p>
<p>ii. 从顶级父类开始，java设置虚方法表，储存可能被经常调用的方法。（非private, 非static, 非final）。虚方法表会继承给子类，子类也会添加自己新的虚方法</p>
</li>
<li><p>继承中的就近原则：</p>
<p>成员变量在使用时，首先在当前方法中寻找；当前方法中找不到，就在当前类中寻找；当前类中找不到，就在父类中寻找。</p>
<p>更精准的用法：当前方法内直接使用，当前类中使用时添加this.前缀，父类变量使用时添加super.前缀</p>
<p><strong>最多只能调用到父类的变量，不能调用到更高</strong></p>
<p><strong>就近原则针对this, super都是适用的</strong></p>
</li>
<li><p><strong>方法重写</strong>：当父类的方法不能满足子类现在的需求时，需要进行方法重写。</p>
<p>代码标志：子类中出现了和父类中一模一样的方法声明，<strong>在重写的方法上放@Override</strong>. </p>
<p><strong>方法重写的本质</strong>：在子类的虚方法表中发生覆盖</p>
<p>方法重写的注意事项：</p>
<p>i. 重写方法的名称、形参列表必须与父类中一致</p>
<p>ii. <strong>子类重写父类方法时，访问权限子类必须大于等于父类</strong>。（<strong>访问权限：public &gt; protected &gt; private</strong>）</p>
<p>iii. <strong>子类重写父类方法时，返回值类型子类必须小于等于父类</strong>。如存在继承关系Animinal-&gt;Dog, 只能父类返回Animinal，子类返回Dog，不能相反</p>
<p>iv. 重写方法尽量和父类保持一致</p>
<p>v. 只有被添加到虚方法表中的方法才能被重写</p>
</li>
<li><p><strong>继承中构造方法的访问特点</strong>：</p>
<p>i. 父类的构造方法不会被子类继承（否则与类名不一致），因此子类默认只有无参构造</p>
<p>ii. 子类中所有的构造方法默认线访问父类中的无参构造，再执行自己（因为需要完成父类数据空间的初始化）</p>
<p>iii. <strong>子类构造方法的第一行语句默认都是：super(), 不写也存在，且必须在第一行。如果想要调用父类的有参构造，必须手写super进行调用</strong></p>
</li>
<li><p>this, super使用总结</p>
<p>i. this: 理解为一个变量，表示当前方法调用者的地址值。<strong>在虚拟机眼中，this只是一个局部变量</strong></p>
<p>使用空参创造对象时，如果需要<strong>设置默认值</strong>，方法为：</p>
<p>this(null, 0, “电子科技大学”)</p>
<p>此时this相当于调用本类其他的构造方法，且虚拟机不再默认调用super()，因为其他类已经调用过了</p>
<p>ii. super: 代表父类存储空间</p>
</li>
</ol>
<h3 id="12-多态"><a href="#12-多态" class="headerlink" title="12. 多态"></a>12. 多态</h3><ol>
<li><p>多态：同类型的对象，表现出的不同形态。例：Person p &#x3D; new Student(); <strong>将子类赋值为父类的形态</strong></p>
<p>表现形式：父类类型 对象名称 &#x3D; 子类对象；</p>
<p>多态的前提：i. 有继承关系 ii. 有父类引用指向子类对象 iii. 有方法重写</p>
</li>
<li><p>作用：</p>
<p>例：register(Person p), 里面传入的参数可以是Student, Teacher或Administor, 同时里面调用的函数（如show）也会是对应类型的。</p>
</li>
<li><p>多态调用成员的特点：</p>
<p>主要针对：Animal a &#x3D; new Dog(); </p>
<p>i. 变量调用：编译看左边 ，运行也看左边。（即Javac编译代码的时候，会看左边的父类中有没有这个变量。如果有，则编译成功；反之，则编译失败。）</p>
<p>ii. 方法调用：编译看左边，运行看右边。（即Javac编译代码的时候，会看左边的父类中有没有这个方法。但是在运行的时候，如果子类进行了方法重写，则运行的是子类的方法。）</p>
<p>内存图解：</p>
<img src="D:\learning_programs\hexo_programs\mywebsite\source\_posts\images\java-tutorial\image-20230915170631761.png" alt="image-20230915170631761" style="zoom: 50%;" />
</li>
<li><p>多态的优势：</p>
<p>i. 在多态形式下，右边对象可以实现解耦合，便于扩展和维护。</p>
<p>ii. 定义方法的时候，使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利。例：对于所有对象，都可以用Object指代。 </p>
<p>多态的弊端：</p>
<p>不能调用子类的特有功能（解决方法：变回子类类型。如Dog d &#x3D; (Dog) a; <strong>这里不能随意转类型，比如将Dog转换为Cat</strong>。这里可以使用instanceof进行判断，对象是否属于相应的类。）</p>
<p>（jdk14之后提出新特性：a instanceof Cat d. 作用：如果a是Cat类型，则强转为Cat并赋值给d，否则不强转）</p>
</li>
</ol>
<h3 id="13-包与final"><a href="#13-包与final" class="headerlink" title="13. 包与final"></a>13. 包与final</h3><ol>
<li><p>包：即<strong>文件夹</strong>，用来管理各种不同功能的Java类，方便后期代码维护</p>
</li>
<li><p><strong>包名的规则</strong>：公司域名反写+包的作用，需要全部英文小写</p>
</li>
<li><p>在使用<strong>其他类</strong>时，需要使用<strong>全类名</strong>，如com.itheima.domain.Student()</p>
<p>为了避免使用的全类名过长，我们常常使用import，如import com.itheima.domain.Student</p>
</li>
<li><p>使用java.lang包中的类，或同一个包中的类时，不需要导包；如果使用两个包中的同名类，需要使用全类名</p>
</li>
<li><p>final：<strong>表示不可改变！！！</strong></p>
<p>可修饰对象：</p>
<p>i. 方法（表示该方法是最终方法，<strong>不能被重写</strong>） 一般用于一种规则</p>
<p>ii. 类（表示该类是最终类，<strong>不能被继承</strong>）</p>
<p>iii. 变量（此时可称为<strong>常量</strong>，<strong>只能被赋值一次</strong>）</p>
</li>
<li><p>常量注意事项：</p>
<p>i. 实际开发中，常量一般作为<strong>系统的配置信息</strong>，方便维护</p>
<p>ii. 常量的<strong>命名规范</strong>：单个单词-全部大写；多个单词-全部大写，中间用下划线分隔开</p>
<p>iii. final修饰的变量是基本数据类型时，则变量存储的<strong>数据值</strong>不能改变；</p>
<p>​	final修饰的变量时引用数据类型时，则变量存储的<strong>地址值</strong>不能改变，但是<strong>对象内部</strong>可以改变</p>
<p>​	综上，即<strong>在栈中存储的值是不可改变的</strong></p>
<p>iv. 以字符串为例，因为字符串的值定义中使用了private final byte[]，导致外部既无法获得地址，又无法修改数值，因此无法修改</p>
</li>
</ol>
<h3 id="14-权限修饰符和代码块"><a href="#14-权限修饰符和代码块" class="headerlink" title="14. 权限修饰符和代码块"></a>14. 权限修饰符和代码块</h3><ol>
<li><p>权限修饰符：用来控制一个成员能够<strong>被访问的范围</strong>，可修饰对象：变量，方法，构造方法，<strong>内部类</strong></p>
</li>
<li><p>四种权限修饰符：<strong>private &lt; 空着不写(缺省 &#x2F; 默认) &lt; protected &lt; public</strong></p>
<img src="D:\learning_programs\hexo_programs\mywebsite\source\_posts\images\java-tutorial\image-20231008213613772.png" alt="image-20231008213613772" style="zoom:50%;" />
</li>
<li><p>实际开发中，最常使用的时<strong>private和public</strong></p>
</li>
<li><p>代码块：{代码块}</p>
<p>代码块分类：局部代码块；构造代码块；静态代码块</p>
</li>
<li><p>i. 局部代码块：<strong>方法内的代码块</strong>. 作用：提前结束代码的生命周期（回收变量），但是现在一般不需要使用了</p>
<p>ii. 构造代码块：<strong>写在成员位置，优先于构造方法执行</strong>. 作用：用于构造方法的重复部分，现在也渐渐淘汰了，因为不够灵活</p>
<p>替代方法：</p>
<p>(1) 在一个构造方法中写入该代码块，然后在其他的构造方法中使用this(…)调用该代码块</p>
<p>(2) 将代码块写入新的函数中，通过调用函数实现</p>
<p>iii. <strong>静态代码块</strong>：在构造代码块的基础上，<strong>通过static关键字修饰，随着类的加载而加载，并且自动触发，只执行一次</strong></p>
<p>使用场景：在类加载的时候，用于数据初始化</p>
</li>
</ol>
<h3 id="15-抽象类"><a href="#15-抽象类" class="headerlink" title="15. 抽象类"></a>15. 抽象类</h3><ol>
<li><p>抽象方法：将<strong>共性的</strong>行为（<strong>方法</strong>）抽取到父类中，由于<strong>每一个子类执行的内容是不一样的</strong>，所以<strong>在父类中不能确定具体的方法体</strong>。</p>
<p>抽象类：如果一个<strong>类中存在抽象方法</strong>，那么该类就<strong>必须声明为抽象类</strong></p>
</li>
<li><p>定义格式：public abstract class 类名() {}</p>
</li>
<li><p>注意事项：</p>
<p>i. 抽象类<strong>不能实例化</strong></p>
<p>ii. 抽象类中<strong>不一定有抽象方法</strong>，有抽象方法的类一定是抽象类</p>
<p>iii. 抽象类<strong>可以有构造方法</strong> （作用：便利子类的构造）</p>
<p>iv. 抽象类的子类要么<strong>重写抽象类中的所有抽象方法</strong>，要么是<strong>抽象类</strong></p>
</li>
<li><p>抽象类和抽象方法的意义：<strong>强制</strong>子类按照规定的格式书写</p>
</li>
</ol>
<h3 id="16-接口"><a href="#16-接口" class="headerlink" title="16. 接口"></a>16. 接口</h3><ol>
<li><p>为什么有接口：整个体系中，<strong>部分个体</strong>具有的<strong>共性</strong>，属于一种<strong>规则</strong>，是对<strong>行为</strong>的抽象。如动物类中，可以定义拥有有用功能的接口。</p>
</li>
<li><p>定义格式：使用关键字interface来定义，public interface 接口{}</p>
<p>i. 接口<strong>不能实例化</strong></p>
<p>ii. 接口和类之间是实现的关系，通过implements关键字表示</p>
<p>iii. 接口的子类<strong>要么重写接口的所有类，要么是抽象类</strong></p>
<p>iv. 接口和类的实现关系，可以是<strong>单实现</strong>，也可以是<strong>多实现</strong></p>
<p>v. 实现类可以在继承一个类的同时，实现多个接口</p>
<p>vi. <strong>接口在定义之后，需要在内部定义对应的抽象方法！！！</strong></p>
</li>
<li><p>接口中成员的特点：</p>
<p>i. 成员变量 - 只能是<strong>常量</strong>，默认修饰符：<strong>public static final</strong></p>
<p>ii. 构造方法 - 没有(接口不能创造对象)</p>
<p>iii. 成员方法 - JDK7之前<strong>只能用抽象方法</strong></p>
</li>
<li><p>接口与类的关系</p>
<p>i. 类和类之间的关系：<strong>继承关系</strong>，只能单继承，不能多继承，但是可以多层继承</p>
<p>ii. 类与接口的关系: <strong>实现关系</strong>，可以但是先，也可以多实现，还可以在继承一个类的同时实现多个接口</p>
<p>​	多个接口中的抽象方法重名时，<strong>只需要重写一次即可</strong></p>
<p>iii. 接口和接口的关系：<strong>继承关系</strong>，可以单继承，也可以多继承。如果实现类实现了最下面的子接口，则需要重写所有的抽象方法</p>
</li>
<li><p>JDK8开始接口中新增方法：接口中可以定义有方法体的方法（<strong>默认，静态</strong>）；JDK9之后，接口中 可以定义<strong>私有方法</strong></p>
<p>原因：<strong>在JDK7中，如果接口发生变化，则所有实现类都要随之改变，否则报错，很不方便</strong>。 </p>
<p>解决方法：</p>
<p>i. JDK8中允许接口定义<strong>默认方法</strong>，需要使用关键字<strong>default</strong>修饰。定义格式：public default void show(){}</p>
<p>注意事项：</p>
<p>(1) 默认方法不是抽象方法，不强制被重写。但如果被重写，重写的时候去掉default关键字</p>
<p>(2) public可以省略，default不能省略</p>
<p>(3) 如果实现了多个接口，多个接口中存在相同名字的默认方法，<strong>子类就必须对该方法进行重写</strong></p>
<p>ii. <strong>静态方法</strong>：使用static进行修饰，定义格式：public static void show()</p>
<p>注意事项：</p>
<p>(1) 接口方法只能通过接口名调用，不能通过实现类名或者对象名调用</p>
<p>(2) public可以省略，static不能省略</p>
<p>(3) <strong>不能重写！！！</strong></p>
<p>iii. <strong>私有方法</strong>：接口中需要抽取重复代码时，就可以使用private。原因：这些方法只希望本接口使用，而不希望被外部引用</p>
<p>格式1：private void show(){} （<strong>为默认方法服务</strong>）</p>
<p>格式2：private static void show(){} (<strong>为静态方法服务</strong>)</p>
</li>
<li><p>接口的应用：</p>
<p>i. 将多个类都可能用到的规则定义为接口</p>
<p>ii. <strong>接口的多态</strong>：<strong>使用接口作为方法的传入参数，就可以传入任何实现了该接口的对象</strong></p>
</li>
<li><p><strong>设计模式</strong>(Design pattern)：一套被反复使用，多数人知晓，经过分类编目的、代码设计经验的总结。</p>
<p>使用设计模式，是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性</p>
<p><strong>适配器设计模式</strong>：解决接口与接口实现类之间的矛盾问题。例：对于接口Inter，首先设计实现类InterAdapter（<strong>一般设置为抽象类abstract</strong>）, 所有实现方法为空；随后使用的实现类InterImpl，就只需要继承类InterAdapter, 然后再重写自己需要的类即可。</p>
<p>如果此时实现类需要继承其他类，<strong>只需要重新设计适配器，多层继承即可</strong></p>
</li>
</ol>
<h3 id="17-内部类"><a href="#17-内部类" class="headerlink" title="17. 内部类"></a>17. 内部类</h3><ol>
<li><p>类的<strong>五大成员</strong>：属性，方法，构造方法，代码块，内部类</p>
</li>
<li><p>内部类：在一个类的内部，再定义一个类</p>
</li>
<li><p>内部类的访问特点：</p>
<p>i. 内部类可以直接访问外部类的成员，<strong>包括私有</strong></p>
<p>ii. 外部类要访问内部类的成员，<strong>必须创建对象</strong></p>
</li>
<li><p>使用场景：B类表示的事物是A类的一部分，且B单独存在没有意义</p>
</li>
<li><p>内部类的分类：</p>
<p>i. 成员内部类 - 写在成员位置，属于外部类的成员，可以被修饰符修饰，如private, 默认, protected等</p>
<img src="D:\learning_programs\hexo_programs\mywebsite\source\_posts\images\java-tutorial\image-20231009103309534.png" alt="image-20231009103309534" style="zoom:50%;" />

<p>获取成员内部类对象：</p>
<p>(1) <strong>使用外部类的对象进行调用</strong>：Outer.Inner oi &#x3D; new Outer().new Inner();</p>
<p>(2) <strong>对于私有化的内部类，可以编写getInstance方法进行创建</strong></p>
<p>成员变量获取外部类变量的方法：</p>
<img src="D:\learning_programs\hexo_programs\mywebsite\source\_posts\images\java-tutorial\image-20231009105355122.png" alt="image-20231009105355122" style="zoom:50%;" />

<p>在内部类中，会存储一个Outer.this(具体名称)，来代表外部类对象的地址值</p>
<p>ii. 静态内部类 - <strong>成员内部类的一种，使用static修饰</strong>。只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要创建对象。</p>
<p>创建格式：外部类名.内部类名 对象名 &#x3D; new 外部类名.内部类名（）；</p>
<p>调用非静态方法：先创建对象，用对象调用</p>
<p>调用静态方法：外部类名.内部类名.方法名</p>
<p>iii. 局部内部类 - 将内部类定义在<strong>方法内部</strong>。</p>
<p>注意事项：</p>
<p>(1) 外界无法直接使用，需要在方法内部创建对象并使用</p>
<p>(2) 该类可以直接访问外部类的成员，也可以访问方法内的局部变量</p>
<p>iv. <strong>匿名内部类</strong></p>
<p>本质：隐藏了名字的内部类</p>
<img src="D:\learning_programs\hexo_programs\mywebsite\source\_posts\images\java-tutorial\image-20231009111558286.png" alt="image-20231009111558286" style="zoom:50%;" /></li>
</ol>
<h3 id="18-游戏打包exe"><a href="#18-游戏打包exe" class="headerlink" title="18. 游戏打包exe"></a>18. 游戏打包exe</h3><ol>
<li><p>游戏打包exe要考虑的因素</p>
<ul>
<li>一定要包含<strong>图形化界面</strong></li>
<li><strong>代码</strong>要打包起来</li>
<li><strong>游戏用到的图片</strong>也要打包</li>
<li><strong>jdk</strong>也要打包</li>
</ul>
</li>
<li><p>游戏打包的核心步骤</p>
<p>i. 将所有代码打包成一个压缩包，<strong>jar</strong>后缀的压缩包</p>
<p>ii. 把jar包<strong>转换成exe</strong>安装包</p>
<p>iii. 将第二步的<strong>exe，图片，jdk</strong>整合在一起，变成最终的exe安装包</p>
</li>
<li><p>exe4j仅支持jdk8-11，但jdk14之后可以考虑直接使用jpackage</p>
</li>
</ol>
<h3 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="*IDEA快捷键"></a>*IDEA快捷键</h3><ol>
<li><p>psvm: public static void main(String[] args);</p>
</li>
<li><p>sout: System.out.println();</p>
</li>
<li><p>fori：构建for(int i&#x3D;0, i&lt; ; i++)循环体</p>
</li>
<li><p>构造类的时候的快捷键：alt+insert (或alt+fn+insert)。可以选择构造函数，set和get</p>
</li>
<li><p>插件PTG 1s生成Javabean: 右键生成Javabean</p>
</li>
<li><p>对于java自带的类，只需要在idea中输入一部分并按回车，就会自动补全import部分</p>
</li>
<li><p>使用鼠标滚轮，可以竖着对idea中的代码进行选择</p>
</li>
<li><p>导入包时，需要选择iml文件，而不是文件夹</p>
</li>
<li><p>ctrl + shift + u: 大写</p>
</li>
<li><p>alt+enter: 对红色波浪线部分进行修正</p>
</li>
<li></li>
</ol>
<h3 id="实践知识积累"><a href="#实践知识积累" class="headerlink" title="实践知识积累"></a>实践知识积累</h3><ol>
<li><p>使用serialization可以轻易实现java中任何数据类型与byte[]之间的互换，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// Create raw data.</span></span><br><span class="line">    Map&lt;Integer, String&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">    data.put(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    data.put(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    System.out.println(data.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert Map to byte array</span></span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">byteOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteOut);</span><br><span class="line">    out.writeObject(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse byte array to Map</span></span><br><span class="line">    <span class="type">ByteArrayInputStream</span> <span class="variable">byteIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteOut.toByteArray());</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteIn);</span><br><span class="line">    Map&lt;Integer, String&gt; data2 = (Map&lt;Integer, String&gt;) in.readObject();</span><br><span class="line">    System.out.println(data2.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>序列化</p>
<p>使用java.io.ObjectInputStream读取序列化的文件时，若读取到第二个类，就会报错：</p>
<p><code>java.io.StreamCorruptedException</code></p>
</li>
</ol>
<p>​		解决方法：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ouhaitao/p/7683514.html">https://www.cnblogs.com/ouhaitao/p/7683514.html</a></p>
<ol start="3">
<li><p>单例模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里只能通过getInstance来获取该单例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">SrcManager</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SrcManager</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">SrcManager</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SrcManager <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/28/c-tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windbro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windbro的小黑屋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | windbro的小黑屋">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/28/c-tutorial/" class="post-title-link" itemprop="url">c++ tutorial</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-10-28 19:48:47 / 修改时间：20:24:10" itemprop="dateCreated datePublished" datetime="2023-10-28T19:48:47+08:00">2023-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/code-tutorial/" itemprop="url" rel="index"><span itemprop="name">code-tutorial</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="vs使用技巧"><a href="#vs使用技巧" class="headerlink" title="vs使用技巧"></a>vs使用技巧</h2><h3 id="一-界面"><a href="#一-界面" class="headerlink" title="一. 界面"></a>一. 界面</h3><ol>
<li>solution：一些project相互联系形成</li>
<li>不要依赖error窗口，最好去观察<strong>output窗口</strong></li>
<li>project中的Header Files等<strong>并不实际存在与之对应的文件夹，它们只是filter，不是directory!</strong> 我们可以使用Show All Files，使其展现实际的目录</li>
<li>因此，我们可以在Show All Files后，创建<strong>src</strong>文件夹来存储所有的<strong>cpp文件和头文件</strong>，并不会影响原本的Source Files等filter中的文件架构</li>
<li>项目中产生的中间文件在.&#x2F;x86&#x2F;Debug中，而.&#x2F;Debug中存储的是最终结果</li>
<li>尽量不要使用全局变量</li>
</ol>
<h3 id="二-Debug"><a href="#二-Debug" class="headerlink" title="二. Debug"></a>二. Debug</h3><ol>
<li><p>debug的两大部分：<strong>断点和读取内存</strong></p>
</li>
<li><p>电脑永远是正确的（笑，至少在99%的条件下），问题都在程序员</p>
</li>
<li><p>断点：程序中调试器将中断的点。运行程序被挂起，我们可以查看<strong>内存</strong>中的状态（state）</p>
<p><strong>在没有代码的行或不执行的行上打断点是没有意义的，必须搭载将要执行的代码行上</strong></p>
</li>
<li><p>内存：内存中未初始化的变量所占空间一般都是用<strong>cc</strong>进行填充，这些地方即为<strong>栈空间</strong> (<strong>该特点仅在win32环境(即x86)下生效，在x64下被取消了</strong>)</p>
</li>
</ol>
<h3 id="三-编程技巧"><a href="#三-编程技巧" class="headerlink" title="三. 编程技巧"></a>三. 编程技巧</h3><ol>
<li>always使用const来引用对象，不要copy</li>
<li>使用c++的原因：性能，控制，底层优化</li>
</ol>
<h2 id="C-基础知识"><a href="#C-基础知识" class="headerlink" title="C++基础知识"></a>C++基础知识</h2><h3 id="一-编译"><a href="#一-编译" class="headerlink" title="一. 编译"></a>一. 编译</h3><ol>
<li><p>cpp文件不等同于翻译单元！可能存在多个cpp文件共同组成一个cpp文件，随后进行编译，此时共同组成的大cpp文件是一个翻译单元，在编译后生成一个obj文件</p>
</li>
<li><p>**编译通常分为两个阶段：compile (编译) + linking (链接)</p>
</li>
<li><p>常用的预处理语句：include, define, if, ifdef, pragma</p>
</li>
</ol>
<p>​	include: <strong>COPY and PASTE</strong>. 复制头文件的内容，粘贴到新的文件中。在vs中可以将预处理结果和输出结果输出到.i文件中。<strong>当生成.i文件时，vs不会再生成obj文件</strong>，所以我们一般禁用</p>
<p>​	在include中, &lt;&gt;只用于编译器包含路径，而**””同时可以用于编译器包含路径和相对路径**，但一般我们只用来表示相对路径。</p>
<p>​	C++标准库没有.h后缀（如iostream），而C标准库有，这是设计者对两者的区分标准</p>
<p>​	define: <strong>FIND and REPLACE</strong>, 在代码中找到所有以前者命名的部分，然后替换为后者</p>
<p>​	pragma once: 阻止单个头文件被多次包含，并转换为单个翻译单元 （比如结构体，重复包含会报错）</p>
<p>​	ifNdef （变量）endif: 检查后边的变量是否被定义，如果未定义就执行</p>
<ol start="4">
<li>output中的错误类型：</li>
</ol>
<p>​		C… : 代表在编译阶段出错</p>
<p>​		LNK…: 代表在链接阶段出错</p>
<ol start="6">
<li><p><strong>项目的入口一般是main函数，但不一定是main函数</strong>。对于一个应用（Application）来说，入门是可以调整的</p>
</li>
<li><p>常见的链接错误：</p>
<p><strong>unresolved external symbol</strong>: 链接器找不到它所需要的东西。<strong>只有在cpp文件中，真实发生了函数调用，连接器才会去链接。</strong>如果只是声明了函数，但是实际文件中没有使用，那么链接器是不会链接的，也不会发生链接错误。这里也有一个前提条件，就是保证<strong>函数绝对不会被调用！</strong>如果这个函数写在了另一个函数里面，那就是可能调用，因此也会链接。</p>
<p>重复：函数或变量重名，链接器不知道链接哪一个 </p>
<hr>
<p><strong>重复的重要例子</strong>：在.h文件中写明了函数体，然后在两个cpp文件中分别include该.h文件，发生重复错误</p>
<p>错误原因：include只是简单的复制粘贴，这导致在两个cpp文件中分别具有该函数体的定义，并分别编译了一遍</p>
<p>解决方法：</p>
<p>i. 在.h文件中，将函数体定义为static，这样在只在每一个翻译单元内有效</p>
<p>ii. 在.h文件中，将函数体定义为inline，这样相当于没有调用函数，而是直接使用代码块</p>
<p>iii. (推荐) 在.h文件中只有函数声明文件，然后在一个翻译单元中写对应的函数体</p>
</li>
<li><p>extern: 表示编译器将从该翻译单元外来寻找该变量</p>
</li>
</ol>
<h3 id="二-基本数据类型"><a href="#二-基本数据类型" class="headerlink" title="二. 基本数据类型"></a>二. 基本数据类型</h3><ol>
<li><p>基本数据类型：char(1), short(2), int(4), long(4), long long (8), float(4), double(8), bool(1)： </p>
</li>
<li><p>在C++中，不同变量类型之间的唯一区别在于它们的<strong>大小</strong></p>
</li>
<li><p>unsigned_int: 无符号数，不是负数，可以将正数的范围扩大一倍</p>
</li>
</ol>
<p>​	4. <strong>一般来说，我们用char代表字符，不用来存储数组</strong></p>
<p>​		在c++中，小数<strong>默认为double</strong>类型，如果要用float类型表示小数，可以在小数后面添加<strong>f或F</strong></p>
<pre><code>5. **sizeof**：查看数据类型的字节数
</code></pre>
<ol start="5">
<li><p>关键字const: 在代码生成上没什么用，主要针对<strong>开发者</strong>，相当于一个承诺。</p>
<p>一种简单的绕过方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const int MAX_AGE = 90;</span><br><span class="line">int num = 10;</span><br><span class="line">int* a = new int;</span><br><span class="line">// 这里如果不使用类型转换，就会报错</span><br><span class="line">a = (int*)&amp;MAX_AGE;</span><br><span class="line">// 这里是设置指针指向的内容为const，会使得无法通过逆向引用改变该空间的值，但是该指针指向的地址仍然是可变的；同时，该指针向的数据仍然是可读的</span><br><span class="line">const int* b = MAX_AGE;</span><br><span class="line">// 正确的，不会报错</span><br><span class="line">b = &amp;num;</span><br><span class="line">// 设置指针本身为const，可以改变该空间的值，但是该指针无法指向其他数据</span><br><span class="line">int* const p;</span><br><span class="line"></span><br><span class="line">// 类内使用</span><br><span class="line">class Entity</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	int m_X, int m_Y;</span><br><span class="line">public:</span><br><span class="line">	// 这里的const仅在类内有效，标明我们不会通过该方法去修改类内的变量</span><br><span class="line">	int const GetX() const</span><br><span class="line">	&#123;</span><br><span class="line">		return m_X;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​		类内方法const的产生原因：</p>
<p>​		在部分时候，我们将类的对象传递给一个新的函数时，需要确保这个函数内不会修改该对象，因此会将类的参数前添加const。这时候如果类中有方法能够直接修改参数，会与我们此时的目的矛盾。</p>
<p>​		因此在c++中，如果我们使用const传递一个类的对象，那么在该函数中我们只能使用该类的const方法，不能使用其他方法。<strong>所以，我们要注意定义类的方法为const</strong> (有时候我们也会使用方法重载的方法，定义一个方法为const, 而另一个方法不是)</p>
<p>​		在c++的const方法中修改变量的方法：</p>
<p>​		**定义该变量为mutable (可更改的)**，这样即使在const方法中，我们也能够修改该变量。</p>
<ol start="6">
<li><p>关键字mutable: 主要用于两个场景 - const 和lambda </p>
<p>​		mutable在const方法中的应用场景：（最常见的方法）本质上我们希望该方法并不改变类中的变量，但是又由于一定原因希望它能够修改部分变量（比如在调试的过程中，我们希望在原本的const方法中，确定该方法调用了多少次，因此就需要一个计数器）</p>
<p>​		mutable在lambda中的应用场景（非常少见）：</p>
<p><img src="D:\learning_programs\hexo_programs\mywebsite\source_posts\images\c-tutorial\image-20231025120016660.png" alt="image-20231025120016660"></p>
<p>​		这里我们进行了值传递，在函数内修改了x的值（如果是普通的值传递，这里的修改是不被允许的）。但是在函数外，x的值并没有发生变化</p>
</li>
<li><p>三元运算符：a &#x3D; () ? : ; </p>
<p>一般来说，能使用三元运算符的地方，我们就不用if-else，因为后者需要在运行中创建中间变量，运行速度更三元运算符的嵌套：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s_Speed = s_Level &gt; 5 ? s_Level &gt; 10 ? 15 : 10 : 5;</span><br></pre></td></tr></table></figure>

<p>都满足时输出15，大于5小于10时输出10，否则输出5.</p>
<p><strong>不过一般不要使用三元运算符的嵌套，太让人费解</strong></p>
</li>
<li><p>栈：有自动的作用域，当超过作用域的时候，自动删除</p>
<p>堆：除非手动delete，否则不会消失</p>
</li>
<li><p>操作符new: 使用new的时候，由于需要寻找符合条件的内存，所以很花时间，很慢</p>
<p>使用new创建对象的时候，<strong>默认创建的是一个void类型的指针</strong>，只是通过隐式转换得到了我们所需要的指针类型</p>
<p>new类似+-，可以被重载，他会返回一个指针</p>
</li>
<li><p>隐式转化： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Entity</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	string m_Name;</span><br><span class="line">	int age;</span><br><span class="line">public:</span><br><span class="line">	Entity(string name)</span><br><span class="line">		:m_Name(name), :age(-1)</span><br><span class="line">		&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	Entity(int age)</span><br><span class="line">		:m_Name(&quot;unknown&quot;), :age(age)</span><br><span class="line">		&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printEntity(Entity&amp; e)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// main函数内部</span><br><span class="line">// 这样定义是可行的，因为构造函数中提供了相应的方法</span><br><span class="line">Entity e = &quot;windbro&quot;;</span><br><span class="line">Entity e1 = 23;</span><br><span class="line">// 这样调用函数也是可行的</span><br><span class="line">printEntity(23);</span><br><span class="line">// 假如直接输入windbro，这里我们就需要进行两次隐式转换，这是并不能实现的</span><br><span class="line">// 因此，我们需要先将windbro转换为string类型，然后输入即可</span><br><span class="line">printEntity(string(&quot;windbro&quot;));</span><br><span class="line">// 也可以这样，这样更常用</span><br><span class="line">Entity b(22);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关键字explicit: 放在构造函数前面，组织构造函数的隐式转换。（应用场景，如数学库，因为这时候我们并不希望进行隐式转换）</p>
<p><img src="D:\learning_programs\hexo_programs\mywebsite\source_posts\images\c-tutorial\image-20231025181657494.png" alt="image-20231025181657494"></p>
</li>
<li><p>运算符：<strong>运算符可以看作一个函数</strong>，运算符的重载必须是<strong>必要的且很容易被人理解</strong>，否则就不要进行</p>
<p><img src="D:\learning_programs\hexo_programs\mywebsite\source_posts\images\c-tutorial\image-20231025182830852.png" alt="image-20231025182830852"></p>
<p>对左移符号&lt;&lt;的重载，从而让构造的类能够被cout输出。它必须写在类的外面，因为这是对ostream中内容的重写</p>
<p><img src="D:\learning_programs\hexo_programs\mywebsite\source_posts\images\c-tutorial\image-20231025183050321.png" alt="image-20231025183050321"></p>
</li>
<li><p>关键字this：指向<strong>当前对象实例的指针</strong>。</p>
</li>
<li><p>拷贝：<strong>需要掌握什么时候需要拷贝，什么时候不需要拷贝，从而提高性能</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">// 不同于python，这里的b是一块新的内存空间，因此这里是拷贝</span><br><span class="line">int b = a;</span><br></pre></td></tr></table></figure>

<p>拷贝构造函数：</p>
<p><img src="D:\learning_programs\hexo_programs\mywebsite\source_posts\images\c-tutorial\image-20231025193905406.png" alt="image-20231025193905406"></p>
<p>注意：</p>
<ol>
<li>默认的构造函数是对类内的值进行拷贝。在本例中，我们将m_Buffer指针的值赋给了新的String对象。这就产生了一个bug：当进行拷贝时，原对象和拷贝对象的m_Buffer指向的对象是相同的，会被同时修改或删除，即<strong>浅拷贝</strong>，如果想要深拷贝，我们就需要自己在拷贝构造函数中写。</li>
</ol>
</li>
<li><p>运算符-&gt; : 主要用于类的指针类型使用。</p>
<p>使用箭头获取变量的偏离量，这里的nullptr可以直接用0代替：</p>
<p><img src="D:\learning_programs\hexo_programs\mywebsite\source_posts\images\c-tutorial\image-20231025194925687.png" alt="image-20231025194925687"></p>
</li>
</ol>
<h3 id="三-函数"><a href="#三-函数" class="headerlink" title="三. 函数"></a>三. 函数</h3><ol>
<li><p>主要目的：防止代码重复</p>
</li>
<li><p>注意：<strong>不要过度使用函数，因为函数的调用过程非常耗时，会让程序变慢</strong></p>
</li>
<li><p>函数签名：对函数的声明</p>
</li>
</ol>
<h3 id="四-文件"><a href="#四-文件" class="headerlink" title="四. 文件"></a>四. 文件</h3><ol>
<li>头文件：<strong>声明某些类型的函数或变量，从而能够在程序中使用</strong></li>
</ol>
<h3 id="五-条件语句"><a href="#五-条件语句" class="headerlink" title="五. 条件语句"></a>五. 条件语句</h3><ol>
<li>if语句和分支语句一般伴随着比较大的开销，由于内存的跳转等复杂操作</li>
<li>对于指针来说，如果指针为null，其相当于0，也可以直接放在判断条件中表示错误</li>
<li>if … else if … , else if实际上是两个语句，一个else语句，一个if语句。<strong>else if 不是c++中的关键字</strong></li>
<li>实际中可以使用<strong>数学计算来代替条件语句</strong>，这样可以大大提高程序的速度。</li>
</ol>
<h3 id="六-循环语句"><a href="#六-循环语句" class="headerlink" title="六. 循环语句"></a>六. 循环语句</h3><ol>
<li><p>一般循环语句指for loop 和 while loop，还有do while，但是现在并不常见</p>
</li>
<li><p>for loop和while loop使用的一般习惯：</p>
<p>当所需要比较的条件（如一个条件变量）发生改变的时候，往往使用for loop。<strong>这时候我们还往往需要使用变化量</strong></p>
<p>当所需要比较的条件不发生改变的时候，往往使用while loop</p>
</li>
<li><p>控制语句：continue:, break, return</p>
</li>
</ol>
<h3 id="七-编译优化"><a href="#七-编译优化" class="headerlink" title="七. 编译优化"></a>七. 编译优化</h3><ol>
<li>常数折叠：当判断语句(如if (a&#x3D;&#x3D;1)) 或出现常数计算(如 a &#x3D; 5*6)时，编译器会直接计算对应的结果，并对汇编结果进行优化。</li>
</ol>
<h3 id="八-指针和引用"><a href="#八-指针和引用" class="headerlink" title="八. 指针和引用"></a>八. 指针和引用</h3><ol>
<li><p>编程中最重要的事：<strong>内存</strong>。这也就引出了指针的作用：<strong>管理和操作内存</strong></p>
</li>
<li><p><strong>指针的实质</strong>：一个存储内存地址的数字。 </p>
</li>
<li><p><strong>指针的类型</strong>：它源自于一个问题 - 在我们有了指针来表示内存地址后，我们还需要通过指针来对相应地址的数据进行操作。但是问题在于，<strong>我们如何知道要对地址所在处，多大的内存空间进行处理</strong>。</p>
<p>这就是指针的类型意义所在：它规定了一个指针所处理的内存空间大小。</p>
</li>
<li><p>对于指针来说，<strong>0不是一个有效地址，即0&#x3D;&#x3D;nullptr</strong>。因此从理论上说，我们可以通过void *ptr &#x3D; 0的方式，来赋值一个空指针。</p>
</li>
<li><p>正常的指针赋值过程：int *ptr &#x3D; &a; 定义指针的时候，<strong>最好还是将*定义在紧挨类型的位置</strong>。但是注意：当定义int* a, b的时候，a的类型事指针，而b不是</p>
</li>
<li><p><strong>逆向使用指针</strong>：*ptr. </p>
</li>
<li><p><strong>引用必须引用已有的变量，不能为空，不占用内存</strong>，它们不是典型的变量</p>
</li>
<li><p><strong>引用的变量在初始化后，就不能再更改所该引用所指向的对象</strong></p>
</li>
<li><p>定义引用的时候，将&amp;靠近类型，因为此时的&amp;实质上是一个变量，不是一个运算符</p>
</li>
<li><p>标准的引用格式：int&amp; pa &#x3D; a;</p>
</li>
<li><p>引用的主要作用：用来对函数的变量进行赋值，标明该函数的变量是需要在函数内进行改变的，而不是单纯的值传递。</p>
<p>void myfun(int&amp; a); 此时a的值会在函数体内发生改变</p>
</li>
</ol>
<h3 id="九-类"><a href="#九-类" class="headerlink" title="九. 类"></a>九. 类</h3><ol>
<li><p>C++并不强制使用面向对象对象，它相对中性</p>
</li>
<li><p>类：将功能和数据组合在一起</p>
</li>
<li><p>类的定义末尾要有分号（；）。</p>
</li>
<li><p>类(class)与结构体(struct)的区别，<strong>原理上说，只有一个区别：类中成员默认是私有的，结构体中成员默认是共有的。</strong></p>
<p>对于c++来说，设计者保留struct的原因在于，他想保持对c的后向兼容性….</p>
</li>
<li><p><strong>struct和class在实际使用中的一般准则</strong>：</p>
<p>仅用来表示大量数据的组合时，使用struct</p>
<p>需要大量功能时，使用class</p>
</li>
<li><p>在c++中，类的成员变量和局部变量的区分并不明显，因此我们<strong>可以在成员变量前添加m_来象征其是成员变量</strong>，如m_message </p>
</li>
<li><p><strong>一般来说，可以将pubic variables, private variables, public methods, private methods作为分开的模块来写，方便区分</strong></p>
</li>
<li><p>static的用法：</p>
<p>在类或结构体外，表示声明为static的符号，链接只能在同一个翻译单元内；</p>
<p>在类或结构体内，表示声明为static的符号，是类的共有属性或方法，所有实例共享</p>
<p>对于类内使用的static方法，其<strong>不能引用示例的变量</strong>，因为其是所有实例共有的，无法确定引用哪个实例的变量</p>
<p>类的static变量可以通过类名引用，也可以通过实例引用或设置（只要它是public的）</p>
</li>
</ol>
<p>​		<strong>类内使用static修饰的变量，在main函数中使用前需要进行声明！！！</strong> 如int Entity::x ; int Entity::y;</p>
<p>​		<strong>局部静态（local static）</strong>：通过静态static修饰一个函数内的变量（不一定是函数，可以是任何一个作用域），其<strong>生存时间是整个程序运行时间，但是作用范围仅仅在函数（作用域）内</strong></p>
<p>​		局部静态的注意：可能值得诟病的是，当局部变量使用在函数内的时候，它的运行逻辑看起来很像是多次重复定义，但<strong>实际上在第一次定义后，之后并没有重新定义</strong></p>
<p>​		<strong>单例类的定义：</strong></p>
<p><img src="D:\learning_programs\hexo_programs\mywebsite\source_posts\images\c-tutorial\image-20231021203901303.png" alt="image-20231021203901303"></p>
<p>​		单例的原因：使用static修饰，所有类共用一个s_Instance</p>
<p>​		(<strong>这里需要配合构造方法私有化进行食用</strong>)</p>
<p>​		<img src="D:\learning_programs\hexo_programs\mywebsite\source_posts\images\c-tutorial\image-20231021204351164.png" alt="image-20231021204351164"></p>
<p>​		使用局部静态变量</p>
<ol start="6">
<li><p>构造函数的产生目的：对类的参数进行初始化，防止在类使用类的参数时，进而编译错误</p>
<p>构造函数的格式: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Entity&#123;</span><br><span class="line">	float X, Y;</span><br><span class="line">	Entity(float x, float y)&#123;</span><br><span class="line">		X = x;</span><br><span class="line">		Y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	Entity()&#123;</span><br><span class="line">		X = 0.0f;</span><br><span class="line">		Y = 0.0f;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><strong>构造函数的名称必须与类名相同</strong></li>
<li>在c++中，默认是由构造函数的，但是默认的构造函数什么都不做，<strong>所以必须进行初始化</strong></li>
<li>构造函数可以重载，即参数的类型不同</li>
<li>禁止构造函数的方法：i. 私有化 ii. 构造函数 &#x3D; delete</li>
</ol>
</li>
<li><p><strong>构造函数初始化列表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Entity()</span><br><span class="line">&#123;</span><br><span class="line">private: </span><br><span class="line">	int m_Name,</span><br><span class="line">	int x, y, z;</span><br><span class="line">public:</span><br><span class="line">	Entity()</span><br><span class="line">		: m_Name(&quot;Unknown&quot;), x(0), y(0), z(0)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	Entity(const std::string&amp; name)</span><br><span class="line">		: m_Name(name)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：</p>
<ol>
<li>构造函数初始化列表时，一定要<strong>按照类内参数声明的顺序来写</strong></li>
<li>构造函数产生的原因：在构造函数中，出了参数赋值外，还可能伴随着其他的操作。初始化列表可以让构造函数更加简洁易懂</li>
<li>对于构造函数来说，如果不适用构造函数初始化列表，<strong>那么我们在调用构造函数的时候实际上创建了两遍对象</strong>：第一遍创造空对象，第二遍创建赋值的对象。因此，对我们来说，<strong>最好到处都使用构造函数初始化列表</strong></li>
</ol>
</li>
<li><p><strong>析构函数</strong>：卸载函数，删除内存时使用</p>
<p>析构函数格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~Entity()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>析构函数注意事项：</p>
</li>
<li><p>析构函数在对象销毁时调用。如果不是手动销毁的话，<strong>一般就是变量作用域（如函数）结束的使用调用</strong></p>
</li>
<li><p>为什么要有析构函数：在析构函数中销毁所有变量，<strong>尤其是手动在栈上分配的内存，它们需要手动清理</strong>。手动创建的对象是析构函数最大的应用情景</p>
</li>
<li><p>析构函数一般不手动调用</p>
</li>
<li><p><strong>继承</strong>：扩展现有类，提供新功能</p>
<p>多态：一个对象，多个类型</p>
<p>继承格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Player : public Entity</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>虚函数</strong>：允许在子类中重写方法, 标记词是visual</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Entity</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	visual std::string GetName() &#123;return &quot;Entity&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Player : public</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	std::string GetName() override &#123;return &quot;Player&quot;;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p>如果在继承的子类中调用与父类相同的方法，那么会根据当前对象的类型，去调用对应的方法。</p>
<p>如子类Player, 父类Entity, 对象p。如果使用一个指向对象p的指针，但是指针的类型是Entity*，那么调用的方法就会使父类中的对应方法</p>
</li>
<li><p>如果想要重写一个函数，就必须将基类中的基函数标记为虚函数</p>
</li>
<li><p><strong>子类中函数名后需要写override</strong>。这不是必须的，但最好这么做，可以起到提示的作用</p>
</li>
<li><p>虚函数的运行成本：v表内存；运行虚函数时，需要使用额外的操作</p>
</li>
<li><p>c++可以<strong>继承多个类</strong></p>
</li>
</ol>
</li>
<li><p>纯虚函数：<strong>与Java中的接口相同</strong>。在基类中顶一个没有实现的函数，然后<strong>强制子类去实现该函数</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Entity</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual std::string GetName() = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p>如果类全部由纯虚函数构成，即为<strong>接口</strong>，无法实例化</p>
</li>
<li><p><strong>只有实现了所有虚函数，才能实例化</strong></p>
</li>
<li><p>方法传参的类型，<strong>可以使用虚函数</strong>，从而要求对象拥有某个虚函数对应方法</p>
</li>
</ol>
</li>
<li><p><strong>可见性</strong>：可见性对程序实际运行方式完全没有影响，对程序性能也没有影响，只是为了更好地写代码或组织代码。</p>
<p>c++中三个基础的可见性修饰符：<strong>private，public，protected</strong></p>
</li>
<li><p>private：只有在<strong>该类的作用域才能访问该变量或方法</strong>，<strong>可以加上它的友元friend</strong></p>
<p>protected: 只有在<strong>该类和它的子类</strong>中可以访问</p>
<p>public：所有对象均可访问</p>
</li>
<li><p>注意：</p>
<ol>
<li><strong>可见性与性能无关！</strong>这是有关<strong>代码阅读和维护</strong>的<strong>风格</strong>问题，它的作用是<strong>提醒程序员自己某个变量和方法应该怎么用</strong></li>
<li>不要<strong>总是将一个变量都设为私有</strong>，它们只是特定的</li>
</ol>
</li>
<li><p>类的实例化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 这样实例化时可以的，因为我们有默认构造函数</span><br><span class="line">// 尽量使用该方式进行实例化</span><br><span class="line">Entity entity;</span><br><span class="line">Entyty entity = Entity(&quot;windbro&quot;)</span><br><span class="line"></span><br><span class="line">// 建立在堆上，这样超过作用域也不会被删除</span><br><span class="line">Entity* e = new Entity(&quot;windbro&quot;)</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>在堆上建立类会更花时间，并且需要手动delete，因此<strong>尽量不要使用new的方式创建类</strong></li>
<li>使用指针的时候，引用变量要使用-&gt;，但是使用直接的类对象的时候，使用.即可</li>
<li>在堆上建立的情况：i. 创建的对象非常大 ii. 需要手动控制对象的作用域和存在时间</li>
</ol>
</li>
</ol>
<h3 id="十-枚举"><a href="#十-枚举" class="headerlink" title="十. 枚举"></a>十. 枚举</h3><ol>
<li><p>枚举的一般格式：</p>
<p><img src="D:\learning_programs\hexo_programs\mywebsite\source_posts\images\c-tutorial\image-20231021204808894.png" alt="image-20231021204808894"></p>
</li>
<li><p>枚举注意：</p>
<p>i. <strong>枚举的类型可以指定为char, int或其他，但是必须是整数类型，默认为int</strong>。</p>
<p>ii. <strong>里面的A是可以直接作为变量被引用的</strong>，如：x &#x3D; A</p>
<p>iii. 枚举内的变量与类中的其他变量没有区别，但注意<strong>不要与其他方法重名</strong>，否则在引用时会出错</p>
</li>
<li><p>枚举的作用：用来<strong>规定一个离散化的取值范围</strong>，从而防止某需要的变量被定义为其他值.</p>
</li>
</ol>
<h3 id="十一-进阶数据类型"><a href="#十一-进阶数据类型" class="headerlink" title="十一. 进阶数据类型"></a>十一. 进阶数据类型</h3><ol>
<li><p>数组：让大量的变量更加可以维护</p>
</li>
<li><p>注意：</p>
<ol>
<li><p><strong>指针</strong>是数组的基础</p>
</li>
<li><p>在<strong>release</strong>版本中，数组越界可能不会被报错，写入错误的内存空间</p>
</li>
<li><p>使用for循环的时候，一般都使用&lt;而不是小于等于，因为性能</p>
</li>
<li><p><strong>使用new创建的变量</strong>时创建在<strong>栈</strong>上面的，因此当函数结束后，其不会消失，同时<strong>也意味着需要手动删除delete</strong></p>
</li>
<li><p>对于数组的删除，需要使用<strong>delete[] arr</strong></p>
</li>
<li><p>当使用<strong>函数返回数组</strong>时，必须使用<strong>new</strong>，否则该数组会被自动删除（当数组在数组内创建时）</p>
</li>
<li><p>对于使用原始方法创建的数组，<strong>不能直接获得数组的大小，但是可以间接计算</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 原始方法</span><br><span class="line">int arr[6];</span><br><span class="line"># 间接计算</span><br><span class="line">int count = sizeof(a) / sizeof(int)</span><br><span class="line"># 解决方法</span><br><span class="line"># 这里不能直接使用size，因为c++不允许数组的长度被初始化为变量</span><br><span class="line">static const int size = 5;</span><br><span class="line">int arr[size];</span><br></pre></td></tr></table></figure>

<p>但是对于在堆创建的数组，这样时错误的。</p>
<p><strong>更好的解决方法：</strong>使用c++ array</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;int, 5&gt; another;</span><br><span class="line">another.size();</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>字符串：编辑和处理文本所用，<strong>字符串就是字符数组</strong>，最简单的用法即为</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char* name = &quot;windbro&quot;;</span><br></pre></td></tr></table></figure>

<p>​		缺点：使用const修饰时，不能改变字符串；即使不适用const，也不能扩大字符串</p>
<ol start="4">
<li><p>注意</p>
<ol>
<li><p>字符串<strong>并不定义在堆上</strong>，所以delete是没有用的</p>
</li>
<li><p>字符串结尾有’\0’，如果我们在字符串中间写’\0’，往往会破坏该字符串的行为。比如strlen，它只会计算\0前面的字符串长度</p>
<pre><code>3. 标准用法：string库，在string类型的构造方法中，它接收一个**const char*类型**的数据。
</code></pre>
<p>  所以在c++中使用字符串的时候，<strong>最好定义字符串的类型为const char</strong><em>, 而不是<strong>char</strong></em>，除非你想得到它的完全控制。但是<strong>最好不要使用该方法去修改字符串</strong>，因为这种修改方法在c++标准中是没有定义的，可能会引发错误</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># include&lt;string&gt;</span><br><span class="line"></span><br><span class="line"># 下述操作在main函数中</span><br><span class="line">std::string name = &quot;windbro&quot;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>在string类型中，有对字符串的各种用法，如字符串的长度、添加和赋值等</p>
<p>注意：</p>
<ol>
<li><p>string str &#x3D; “aaa” + “bbb” 是一个<strong>错误的字符串拼接方法</strong>，因为此时后两者相当于const char*，而不是字符串类型。</p>
<p>为了解决该问题，我们可以将该操作分成两行来写，也可以将其中一个直接转换为string</p>
</li>
<li><p><strong>字符串的传递</strong>：如果直接将字符串传递给另一个函数，那么实际的操作是：先将该字符串复制，然后再将复制后的字符串传递给函数，但是<strong>字符串的复制过程是相当慢的！</strong></p>
<p>因此，我们可以在函数中使用 const string&amp; str来传递字符串，这样直接传递引用，同时又保证了我们不会在函数中修改该字符串（<strong>字符串只读</strong>）</p>
<pre><code>    3. 字符串字面量：字符串字面量存储在**内存的只读部分**，因此不能通过name[2] = &#39;a&#39;进行修改
</code></pre>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char* name = &quot;windbro&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>几种其他的字符编码（默认u8, 否则需要在字符串前注明）：</p>
<p><img src="D:\learning_programs\hexo_programs\mywebsite\source_posts\images\c-tutorial\image-20231025112651752.png" alt="image-20231025112651752"></p>
<p>注意：</p>
<ol>
<li><p>字符串字面量不同于字符数组，前者不可编辑 ，后者可以</p>
</li>
<li><p>字符串字面量的一些常用方法：</p>
<p><img src="D:\learning_programs\hexo_programs\mywebsite\source_posts\images\c-tutorial\image-20231025113323304.png" alt="image-20231025113323304"></p>
</li>
</ol>
</li>
</ol>
<p>​			s: 将字符串字面量转换为字符串</p>
<p>​			R: 方便换行</p>
<ol start="7">
<li><p>智能指针：<strong>针对调用new的时候必须调用delete。</strong></p>
<ul>
<li><p>unique_ptr: 当对象超过作用域的时候，自动删除。<strong>unIque_ptr只能是唯一指向特定内存块的指针</strong> 。<strong>不能被复制，指向的内容不能被分享</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 这里不能使用 unique_ptr&lt;Entity&gt; entity = new Entity(), 因为隐式类型转换</span><br><span class="line">unique_ptr&lt;Entity&gt; entity(new Entity())</span><br><span class="line"></span><br><span class="line">// 更一般的写法, 处于异常安全考虑，这里创建了一个新的对象</span><br><span class="line">unique_ptr&lt;Entity&gt; entity = make_unique&lt;Entity&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>shared_ptr: 内存块可以被多个引用，<strong>但是如果引用量减到0，那么内存块删除</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Entity&gt; sharedEntity = make_shared&lt;Entity&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>weak_ptr: 可以使用shared_ptr赋值，<strong>它不会增加shared_ptr的计数，即不会确保指向对象的存活</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weak_ptr&lt;Entity&gt; weakEntity = sharedEntity;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>​				优先级顺序：unique_ptr &gt; shared_ptr</p>
<ol start="8">
<li><p>动态数组：**(特别是vector)**. 数据的大小不确定，随着放置元素的数量而增长。</p>
<p>原理：当数组的长度超过最初设定的值时，创建一个更大的数组，将所有数据复制在这里，并删除最初的数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 不同于java，vector中的类型可以是基本数据类型，也可以是非基本数据类型</span><br><span class="line">vector&lt;int&gt; vertices;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>一般来说，<strong>存储对象比存储指针更优</strong>，因为vector中对象的存储是连续的</li>
<li>常用方法：push_back(); size(); erase(vec.begin() + 1);</li>
</ol>
</li>
<li><p>vector优化：针对vector中的复制原理，我们可以首先自己写一个类，然后重写类的拷贝，查看vector在什么时候发生了拷贝。</p>
<p>一个简单的拷贝优化过程：<img src="D:\learning_programs\hexo_programs\mywebsite\source_posts\images\c-tutorial\image-20231025200855629.png" alt="image-20231025200855629"></p>
<p>优化前：使用了6次copy，其中三次是因为每次我们push_back时，vector的长度都在增长，因此我们进行了vector的复制；另外三次是因为我们在push_back的过程中，我们先定义一个Vertex，然后重新赋值</p>
<p><img src="D:\learning_programs\hexo_programs\mywebsite\source_posts\images\c-tutorial\image-20231025200837057.png" alt="image-20231025200837057"></p>
<p> 优化后：reserve首先预定三个位置，然后通过<strong>emplace_back</strong>直接进行参数列表构造，而不是push_back</p>
</li>
</ol>
<p>​		</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/28/Hexo-tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windbro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windbro的小黑屋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | windbro的小黑屋">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/28/Hexo-tutorial/" class="post-title-link" itemprop="url">Hexo tutorial</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-28 15:24:52" itemprop="dateCreated datePublished" datetime="2023-10-28T15:24:52+08:00">2023-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-10 16:07:06" itemprop="dateModified" datetime="2023-11-10T16:07:06+08:00">2023-11-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/code-tutorial/" itemprop="url" rel="index"><span itemprop="name">code-tutorial</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="一-Hexo日常发布文章"><a href="#一-Hexo日常发布文章" class="headerlink" title="一. Hexo日常发布文章"></a>一. Hexo日常发布文章</h3><ol>
<li><p>进入博客所在目录，创建博文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;BlogName&quot;</span><br></pre></td></tr></table></figure>

<p>这时在source文件夹下会出现BlogName.md文件</p>
</li>
<li><p>在BlogName.md文件中写内容…</p>
</li>
<li><p>使用以下代码渲染文章，并部署到GitHub上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g # 生成页面</span><br><span class="line">hexo d # 部署</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="二-网站设置"><a href="#二-网站设置" class="headerlink" title="二. 网站设置"></a>二. 网站设置</h3><p>​		包括网站名称、描述、作者、链接样式等，全部在_config.yml文件中</p>
<p>​		注意：<strong>冒号后要加一个空格</strong></p>
<h3 id="三-更换主题"><a href="#三-更换主题" class="headerlink" title="三. 更换主题"></a>三. 更换主题</h3><p>​		在<a href="https://link.zhihu.com/?target=https://hexo.io/themes/">Hexo|Themes</a>中选择一个喜欢的主题，比如<a href="https://link.zhihu.com/?target=http://theme-next.iissnan.com/getting-started.html">NexT</a>， 进入网站目录使用以下命令下载主题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>​		然后修改_config.yml的theme为新主题名称next，发布。</p>
<h3 id="四-常用命令"><a href="#四-常用命令" class="headerlink" title="四. 常用命令"></a>四. 常用命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;name&quot;       # 新建文章</span><br><span class="line">hexo new page &quot;name&quot;  # 新建页面</span><br><span class="line">hexo g                # 生成页面</span><br><span class="line">hexo d                # 部署</span><br><span class="line">hexo g -d             # 生成页面并部署</span><br><span class="line">hexo s                # 本地预览</span><br><span class="line">hexo clean            # 清除缓存和已生成的静态文件</span><br><span class="line">hexo help             # 帮助</span><br></pre></td></tr></table></figure>

<h3 id="五-主题next文档"><a href="#五-主题next文档" class="headerlink" title="五. 主题next文档"></a>五. 主题next文档</h3><p>​		中文文档：<a target="_blank" rel="noopener" href="https://hexo-next.readthedocs.io/zh-cn/latest/">https://hexo-next.readthedocs.io/zh-cn/latest/</a></p>
<p>​		英文文档：<a target="_blank" rel="noopener" href="https://theme-next.js.org/docs/">https://theme-next.js.org/docs/</a></p>
<p>参考文献：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60578464">https://zhuanlan.zhihu.com/p/60578464</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">windbro</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
